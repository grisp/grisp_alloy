
# UBoot addresses
loadaddr=0x44000000
kernel_addr_r=0x41000000
fdt_addr_r=0x43000000
fdtoverlay_addr_r=0x49000000
ramdisk_addr_r=0x46000000
scriptaddr=0x40000000
pxefile_addr_r=0x40100000
dfu_alt_info=sf 0:0=flash-bin raw 0x400 0x1f0000

# Standard boot environment variables
bootcount=0
# Max boot attempts before calling altbootcmd
bootlimit=3
bootcmd=run alloy_bootcmd;
altbootcmd=run alloy_fallback;

# Alloy custom environment variables
image_base=fitImage
bootargs_base=rootwait console=ttymxc2,115200
bootargs_extra=
alloy_boot_order=mmc1 mmc0

# A/B software upgrade context
# Last known working system (a|b)
valid_system=a
# Currently booted system (a|b)
active_system=a
# New upgrade ready to install (0|1)
upgrade_available=0
# Fallback attempt counter
upgrade_fallback=0

# Firmware general information
system_platform=kontron-albl-imx8mm
system_architecture=aarch64-unknown-linux-gnu

# System A metadata, set during the upgrade process
systema_firmware_uuid=""
systema_firmware_version=""
systema_firmware_vcs_id=""
systema_firmware_author=""

# System B metadata, set during the upgrade process
systemb_firmware_uuid=""
systemb_firmware_version=""
systemb_firmware_vcs_id=""
systemb_firmware_author=""

# Custom commands

alloy_fallback=\
	setexpr upgrade_fallback ${upgrade_fallback} + 1;\
	setenv upgrade_available 0;\
	run alloy_bootcmd;

alloy_bootcmd=\
	for target in ${alloy_boot_order}; do\
		run alloy_bootcmd_${target};\
	done;\
	reset;

# Boot from eMMC with A/B software upgrade
alloy_bootcmd_mmc0=\
	devnum=0;\
	devpart=2;\
	run alloy_boot_ab;

# Boot from SD card
alloy_bootcmd_mmc1=\
	devnum=1;\
	devpart=2;\
	run alloy_boot_simple;

alloy_boot_simple=\
	setenv bootargs root=/dev/mmcblk${devnum}p3 ${bootargs_base} ${bootargs_extra} alloy.boot_id=sd-card;\
	saveenv\
	if load mmc ${devnum}:${devpart} ${loadaddr} ${image_base}; then\
		bootm ${loadaddr};\
	fi;

# A/B boot logic - handles normal boot, upgrades, and fallbacks
# TODO: Enable watchdog before calling bootm when upgrade validation client is implemented
# This will auto-reboot if new system doesn't mark itself as working
#		if test ${upgrade_available} = 1; then
#			wdt dev watchdog@30280000;
#			wdt start 15000;
#		fi;
alloy_boot_ab=\
	if test "${valid_system}" != "a" && test "${valid_system}" != "b"; then\
		echo "WARNING: Invalid valid_system='${valid_system}', defaulting to 'a'";\
		setenv valid_system a;\
	fi;\
	if test ${upgrade_available} -lt 0 || test ${upgrade_available} -gt 1; then\
		echo "WARNING: Invalid upgrade_available=${upgrade_available}, defaulting to 0";\
		setenv upgrade_available 0;\
	fi;\
	if test ${upgrade_fallback} -lt 0; then\
		echo "WARNING: Invalid upgrade_fallback=${upgrade_fallback}, defaulting to 0";\
		setenv upgrade_fallback 0;\
	fi;\
	if test ${valid_system} = a && test ${upgrade_available} = 0 && test ${upgrade_fallback} = 0; then\
		setenv active_system a;\
		setenv image ${image_base}_A;\
		setenv bootargs root=/dev/mmcblk${devnum}p3 ${bootargs_base} ${bootargs_extra} alloy.boot_id=system-a;\
		echo Booting system A: /dev/mmcblk${devnum}p3;\
	elif test ${valid_system} = b && test ${upgrade_available} = 0 && test ${upgrade_fallback} = 0; then\
		setenv active_system b;\
		setenv image ${image_base}_B;\
		setenv bootargs root=/dev/mmcblk${devnum}p4 ${bootargs_base} ${bootargs_extra} alloy.boot_id=system-b;\
		echo Booting system B: /dev/mmcblk${devnum}p4;\
	elif test ${valid_system} = a && test ${upgrade_fallback} -gt 0; then\
		setenv active_system a;\
		setenv image ${image_base}_A;\
		setenv bootargs root=/dev/mmcblk${devnum}p3 ${bootargs_base} ${bootargs_extra}  alloy.boot_id=system-a fallback;\
		echo Falling back to system A: /dev/mmcblk${devnum}p3;\
	elif test ${valid_system} = b && test ${upgrade_fallback} -gt 0; then\
		setenv active_system b;\
		setenv image ${image_base}_B;\
		setenv bootargs root=/dev/mmcblk${devnum}p4 ${bootargs_base} alloy.boot_id=system-b fallback;\
		echo Falling back to system B: /dev/mmcblk${devnum}p4;\
	elif test ${valid_system} = a && test ${upgrade_available} = 1; then\
		setenv active_system b;\
		setenv image ${image_base}_B;\
		setenv bootargs root=/dev/mmcblk${devnum}p4 ${bootargs_base} ${bootargs_extra} alloy.boot_id=system-b alloy.upgrading=true;\
		echo Upgrading to system B: /dev/mmcblk${devnum}p4;\
	elif test ${valid_system} = b && test ${upgrade_available} = 1; then\
		setenv active_system a;\
		setenv image ${image_base}_A;\
		setenv bootargs root=/dev/mmcblk${devnum}p3 ${bootargs_base} ${bootargs_extra} alloy.boot_id=system-a alloy.upgrading=true;\
		echo Upgrading to system A: /dev/mmcblk${devnum}p3;\
	else\
		echo "FATAL: Unexpected system upgrade context";\
		echo "  valid_system=${valid_system}";\
		echo "  upgrade_available=${upgrade_available}";\
		echo "  upgrade_fallback=${upgrade_fallback}";\
		setenv active_system a;\
		setenv image ${image_base}_A;\
		setenv bootargs root=/dev/mmcblk${devnum}p3 ${bootargs_base} ${bootargs_extra} alloy.boot_id=system-a recovery;\
		echo "Emergency boot to system A: /dev/mmcblk${devnum}p3";\
	fi\
	saveenv\
	if load mmc ${devnum}:${devpart} ${loadaddr} ${image}; then\
		bootm ${loadaddr};\
	else\
		echo ERROR: $image not found;\
		reset;\
	fi;
