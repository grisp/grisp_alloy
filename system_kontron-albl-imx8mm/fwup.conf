# Firmware configuration file for Kontron AL/BL i.MX8M Mini on Linux

require-fwup-version="1.4.0"

define(ALLOY_ENV_VER, "1")

#
# Firmware metadata
#

# All of these can be overriden using environment variables of the same name.
#
#  Run 'fwup -m' to query values in a .fw file.
#  Use 'fw_printenv' to query values on the target.
#
define(GRISP_FW_PRODUCT, "Kontron AL/BL i.MX8M Mini Firmware")
define(GRISP_FW_DESCRIPTION, "")
define(GRISP_FW_VERSION, "")
define(GRISP_FW_PLATFORM, "kontron-albl-imx8mm")
define(GRISP_FW_ARCHITECTURE, "aarch64-unknown-linux-gnu")
define(GRISP_FW_AUTHOR, "Peer Stritzinger GmbH")
define(GRISP_FW_VCS_IDENTIFIER, "")
define(GRISP_FW_MISC, "")

# Default paths if not specified via the commandline
define(ROOTFS, "${GRISP_TARGET_SYSTEM}/images/rootfs.squashfs")
define(UBOOT, "${GRISP_SYSTEM}/images/flash.bin")
define(FITIMAGE, "${GRISP_SYSTEM}/images/fitImage")
define(PRIMARY_ENV_BIN, "${GRISP_SYSTEM}/images/uboot-env.bin")
define(SECONDARY_ENV_BIN, "${GRISP_SYSTEM}/images/uboot-env.bin")

# This configuration file will create an image that
# uses GPT and the following layout (partition numbers):
#
# +----------------------------------------+
# | Protective MBR + GPT                   |
# +----------------------------------------+
# | U-Boot @ offset 33KB                   |
# +----------------------------------------+
# | U-Boot Env 1 @ 1.875 MiB               |
# | U-Boot Env 2 @ 1.9375 MiB              |
# +----------------------------------------+
# | p0: Reserved                           |
# +----------------------------------------+
# | p1: Boot (FAT32)                       |
# |     fitImage_A/B                       |
# +----------------------------------------+
# | p2: Rootfs A (squashfs)                |
# +----------------------------------------+
# | p3: Rootfs B (squashfs)                |
# +----------------------------------------+
# | p4: Application (f2fs)                 |
# +----------------------------------------+
#
# WARNING: Always make sure to keep these partitions in sync with crucible.sh

# The U-Boot is written directly to the SDCard/eMMC user area at 33 KiB offset (IMX_BOOT_SEEK)
define(UBOOT_OFFSET, 66)  # 33 KiB = 66 * 512 bytes blocks
# The max size take into account both the flash and the sdcard,
# the bootloader starting at 33 KiB offset on sdcard means the bootloader maximum
# size is 32 KiB lower than what the flash would support.
# Bootloader/environment/raw area configuration
# - UBOOT_BOOT_MAX_COUNT: maximum bootloader size (in 512-byte blocks)
# - Guard and environment areas placed before the first GPT partition
define(UBOOT_BOOT_MAX_COUNT, 8192)          # 4 MiB in 512-byte blocks
define(UBOOT_PRE_ENV_GUARD_COUNT, 256)      # 128 KiB guard before env

# The U-Boot environment on both SDCard and eMMC user area
# Dual environment setup for redundancy
#
# Layout before first GPT partition (all values are 512-byte blocks):
#  66 (33 KiB ROM seek) + UBOOT_BOOT_MAX_COUNT (bootloader)
#  + UBOOT_PRE_ENV_GUARD_COUNT + [env primary (UBOOT_ENV_COUNT)]
#  + [env secondary (UBOOT_ENV_COUNT)]
define(UBOOT_ENV_COUNT, 128)                # 64 KiB (0x10000)
define-eval(UBOOT_ENV_PRIMARY_OFFSET, "${UBOOT_OFFSET} + ${UBOOT_BOOT_MAX_COUNT} + ${UBOOT_PRE_ENV_GUARD_COUNT}")
define-eval(UBOOT_ENV_SECONDARY_OFFSET, "${UBOOT_ENV_PRIMARY_OFFSET} + ${UBOOT_ENV_COUNT}")

# Partition sizes
define(RESERVED_PART_COUNT, 262144)         # 128 MiB
define(BOOT_PART_COUNT, 131072)             # 64 MiB
define(ROOTFS_PART_COUNT, 524288)           # 256 MiB
define(APP_PART_COUNT, 1048576)             # 512 MiB

# Reserve raw space for bootloader + env up to first GPT partition (aligned to 1 MiB)
#   First partition offset (blocks) = 10240 (5 MiB)
#   This leaves room for: 33KiB + 4MiB + guards + 2x64KiB env
define(RESERVED_PART_OFFSET, 10240)    # 5 MiB

# The boot partition contains the fitImage files for A/B boot
define-eval(BOOT_PART_OFFSET, "${RESERVED_PART_OFFSET} + ${RESERVED_PART_COUNT}")

# Let the rootfs have room to grow up to 256 MiB and align it to the nearest 1 MiB boundary
define-eval(ROOTFS_A_PART_OFFSET, "${BOOT_PART_OFFSET} + ${BOOT_PART_COUNT}")
define-eval(ROOTFS_B_PART_OFFSET, "${ROOTFS_A_PART_OFFSET} + ${ROOTFS_PART_COUNT}")

# Application partition. This partition can occupy all of the remaining space.
# Size it to fit the destination.
define-eval(APP_PART_OFFSET, "${ROOTFS_B_PART_OFFSET} + ${ROOTFS_PART_COUNT}")


# Firmware archive metadata
meta-product = ${GRISP_FW_PRODUCT}
meta-description = ${GRISP_FW_DESCRIPTION}
meta-version = ${GRISP_FW_VERSION}
meta-platform = ${GRISP_FW_PLATFORM}
meta-architecture = ${GRISP_FW_ARCHITECTURE}
meta-author = ${GRISP_FW_AUTHOR}
meta-vcs-identifier = ${GRISP_FW_VCS_IDENTIFIER}
meta-misc = ${GRISP_FW_MISC}

# File resources are listed in the order that they are included in the .fw file
# This is important, since this is the order that they're written on a firmware
# upgrade due to the event driven nature of the update system.
file-resource uboot {
    host-path = ${UBOOT}
    assert-size-lte = ${UBOOT_BOOT_MAX_COUNT}
}

file-resource primary-uboot-env {
    host-path = ${PRIMARY_ENV_BIN}
    assert-size-lte = ${UBOOT_ENV_COUNT}
}

file-resource secondary-uboot-env {
    host-path = ${SECONDARY_ENV_BIN}
    assert-size-lte = ${UBOOT_ENV_COUNT}
}

file-resource fitImage {
    host-path = ${FITIMAGE}
}

file-resource rootfs.img {
    host-path = ${ROOTFS}

    # Error out if the rootfs size exceeds the partition size
    assert-size-lte = ${ROOTFS_PART_COUNT}
}

gpt gpt {
    guid = 01999b2e-3fba-7508-9cd5-a58f16f5350a

    partition 0 {
        block-offset = ${RESERVED_PART_OFFSET}
        block-count = ${RESERVED_PART_COUNT}
        type = 8da63339-0007-60c0-c436-083ac8230908  # Linux reserved
        guid = 01999b27-85c6-727c-a37b-c1838a5c93fa
        name = "reserved"
    }
    partition 1 {
        block-offset = ${BOOT_PART_OFFSET}
        block-count = ${BOOT_PART_COUNT}
        type = ebd0a0a2-b9e5-4433-87c0-68b6b72699c7  # Basic data (FAT)
        guid = 01999b27-ae3e-77eb-bc96-2b5da0810af8
        name = "boot"
    }
    partition 2 {
        block-offset = ${ROOTFS_A_PART_OFFSET}
        block-count = ${ROOTFS_PART_COUNT}
        type = 0fc63daf-8483-4772-8e79-3d69d8477de4  # Linux filesystem
        guid = 01999b27-e0ca-73cf-9908-d9d1961a7df0
        name = "rootfs_a"
    }
    partition 3 {
        block-offset = ${ROOTFS_B_PART_OFFSET}
        block-count = ${ROOTFS_PART_COUNT}
        type = 0fc63daf-8483-4772-8e79-3d69d8477de4  # Linux filesystem
        guid = 01999b27-fffa-74af-9f51-aafad27e9e88
        name = "rootfs_b"
    }
    partition 4 {
        block-offset = ${APP_PART_OFFSET}
        block-count = ${APP_PART_COUNT}
        type = 0fc63daf-8483-4772-8e79-3d69d8477de4  # Linux filesystem
        guid = 01999b28-1b5a-738e-9a47-649cf192b781
        name = "data"
        expand = true
    }
}

uboot-environment uboot-env {
    block-offset = ${UBOOT_ENV_PRIMARY_OFFSET}
    block-offset-redund = ${UBOOT_ENV_SECONDARY_OFFSET}
    block-count = ${UBOOT_ENV_COUNT}
}

# This firmware task perform a factory reset of the board bootloader (SPI NOR).
# Should be performed on device /dev/null and --unsafe option is required
# NOTE: Temporary for development until the device boots directly from eMMC.
#       Remove this task once fuses/boot flow are set for eMMC-only boot.
#       It is expected to fail if the bootloader image is larger than 2MB - 1k.
task bootloader {
    # Only match if not mounted
    require-unmounted-destination = true

    on-init {
        info("Starting Kontron AL/BL i.MX8M Mini bootloader initialization (SPI NOR)")
    }

    on-resource uboot {
        info("Flashing U-Boot bootloader...")
        # Erase the entire SPI NOR device
        execute("flash_erase -q /dev/mtd0 0 512")
        pipe_write("dd of=/dev/mtd0 bs=512 seek=2 count=3838 conv=sync status=none")
    }

    on-finish {
        info("Bootloader initialization done")
    }
}

# This firmware task performs a factory reset of the eMMC or sdcard.
# Should be performed on device /dev/mmcblk0 for emmc setup.
task complete {
    # Only match if not mounted
    require-unmounted-destination = true

    on-init {
        info("Starting Kontron AL/BL i.MX8M Mini firmware setup")
        gpt_write(gpt)

        fat_mkfs(${BOOT_PART_OFFSET}, ${BOOT_PART_COUNT})
        fat_setlabel(${BOOT_PART_OFFSET}, "BOOT")

        # Clear out any old data in the rootfs partitions
        trim(${ROOTFS_A_PART_OFFSET}, ${ROOTFS_PART_COUNT})
        trim(${ROOTFS_B_PART_OFFSET}, ${ROOTFS_PART_COUNT})

        uboot_clearenv(uboot-env)
    }

    on-resource uboot {
        info("Writing U-Boot bootloader to eMMC...")
        # Write U-Boot at 33KB offset (required by i.MX8MM boot ROM)
        raw_write(${UBOOT_OFFSET})
    }

    on-resource primary-uboot-env {
        info("Flashing U-Boot main environment...")
        raw_write(${UBOOT_ENV_PRIMARY_OFFSET})
    }

    on-resource secondary-uboot-env {
        info("Flashing U-Boot redundant environment...")
        raw_write(${UBOOT_ENV_SECONDARY_OFFSET})

        info("Customising U-Boot environment...")

        # Override/customize specific variables for factory initialization
        uboot_setenv(uboot-env, "valid_system", "a")
        uboot_setenv(uboot-env, "active_system", "a")
        uboot_setenv(uboot-env, "upgrade_available", "0")
        uboot_setenv(uboot-env, "upgrade_fallback", "0")
        uboot_setenv(uboot-env, "rollback_available", "0")

        # Initialize system A metadata
        uboot_setenv(uboot-env, "systema_firmware_uuid", "\${FWUP_META_UUID}")
        uboot_setenv(uboot-env, "systema_firmware_version", ${GRISP_FW_VERSION})
        uboot_setenv(uboot-env, "systema_firmware_vcs_id", ${GRISP_FW_VCS_IDENTIFIER})
        uboot_setenv(uboot-env, "systema_firmware_author", ${GRISP_FW_AUTHOR})

        # Initialize system B metadata
        uboot_setenv(uboot-env, "systemb_firmware_uuid", "")
        uboot_setenv(uboot-env, "systemb_firmware_version", "")
        uboot_setenv(uboot-env, "systemb_firmware_vcs_id", "")
        uboot_setenv(uboot-env, "systemb_firmware_author", "")

        # Add extra kernel parameters for RT isolation
        # CPU 3 isolated for RT, CPUs 0-2 available for normal system tasks
        uboot_setenv(uboot-env, "bootargs_extra", "isolcpus=3 nohz_full=3 rcu_nocbs=3 rcu_nocb_poll intel_idle.max_cstate=1 processor.max_cstate=1")
    }

    on-resource fitImage {
        info("Writing FIT image...")
        # Write initial fitImage for system A
        fat_write(${BOOT_PART_OFFSET}, "fitImage_A")
        # Cleanup any old system B image
        fat_rm(${BOOT_PART_OFFSET}, "fitImage_B")
    }

    on-resource rootfs.img {
        info("Writing root filesystem to partition A...")
        # write to the first rootfs partition
        raw_write(${ROOTFS_A_PART_OFFSET})
    }

    on-finish {
        info("Finalizing firmware...")

        # Invalidate the application data partition so that it is guaranteed to
        # trigger the corrupt filesystem detection code on first boot and get
        # formatted.
        raw_memset(${APP_PART_OFFSET}, 256, 0xff)

        info("Firmware setup done")
    }
}

# This firmware task upgrades system A when system B is currently active
task upgrade.a {
    # Verify environment version compatibility
    require-uboot-variable(uboot-env, "alloy_env_ver", "${ALLOY_ENV_VER}")

    # Verify we are running from system B
    require-path-at-offset("/", ${ROOTFS_B_PART_OFFSET})

    # Verify that partition B is currently active
    require-uboot-variable(uboot-env, "active_system", "b")

    # Verify that partition B is currently valid
    require-uboot-variable(uboot-env, "valid_system", "b")

    # Verify the expected platform/architecture
    require-uboot-variable(uboot-env, "system_platform", "${GRISP_FW_PLATFORM}")
    require-uboot-variable(uboot-env, "system_architecture", "${GRISP_FW_ARCHITECTURE}")

    # Upgrade to partition A
    on-init {
        info("Upgrading system A (currently running from B)")

        # Any already upgraded system will be destroyed
        uboot_setenv(uboot-env, "upgrade_available", "0")
        # Disable rollback immediately when starting an upgrade
        uboot_setenv(uboot-env, "rollback_available", "0")

        # Reset system A metadata to empty values
        uboot_setenv(uboot-env, "systema_firmware_uuid", "")
        uboot_setenv(uboot-env, "systema_firmware_version", "")
        uboot_setenv(uboot-env, "systema_firmware_vcs_id", "")
        uboot_setenv(uboot-env, "systema_firmware_author", "")

        # Indicate that the entire partition can be cleared
        trim(${ROOTFS_A_PART_OFFSET}, ${ROOTFS_PART_COUNT})
    }

    on-resource fitImage {
        fat_write(${BOOT_PART_OFFSET}, "fitImage_A")
    }

    on-resource rootfs.img {
        raw_write(${ROOTFS_A_PART_OFFSET})
    }

    on-finish {
        uboot_setenv(uboot-env, "systema_firmware_uuid", "\${FWUP_META_UUID}")
        uboot_setenv(uboot-env, "systema_firmware_version", ${GRISP_FW_VERSION})
        uboot_setenv(uboot-env, "systema_firmware_vcs_id", ${GRISP_FW_VCS_IDENTIFIER})
        uboot_setenv(uboot-env, "systema_firmware_author", ${GRISP_FW_AUTHOR})
        uboot_setenv(uboot-env, "bootcount", "0")
        uboot_setenv(uboot-env, "upgrade_available", "1")
        uboot_setenv(uboot-env, "upgrade_fallback", "0")
        info("System A upgraded")
    }

    on-error {
    }
}

# This firmware task upgrades system B when system A is currently active
task upgrade.b {
    # Verify environment version compatibility
    require-uboot-variable(uboot-env, "alloy_env_ver", "${ALLOY_ENV_VER}")

    # Verify we are running from system A
    require-path-at-offset("/", ${ROOTFS_A_PART_OFFSET})

    # Verify that partition A is currently active
    require-uboot-variable(uboot-env, "active_system", "a")

    # Verify that partition A is currently valid
    require-uboot-variable(uboot-env, "valid_system", "a")

    # Verify the expected platform/architecture
    require-uboot-variable(uboot-env, "system_platform", "${GRISP_FW_PLATFORM}")
    require-uboot-variable(uboot-env, "system_architecture", "${GRISP_FW_ARCHITECTURE}")

    # Upgrade to partition B
    on-init {
        info("Upgrading system B (currently running from A)")

        # Any already upgraded system will be destroyed
        uboot_setenv(uboot-env, "upgrade_available", "0")
        # Disable rollback immediately when starting an upgrade
        uboot_setenv(uboot-env, "rollback_available", "0")

        # Reset system B metadata to empty values
        uboot_setenv(uboot-env, "systemb_firmware_uuid", "")
        uboot_setenv(uboot-env, "systemb_firmware_version", "")
        uboot_setenv(uboot-env, "systemb_firmware_vcs_id", "")
        uboot_setenv(uboot-env, "systemb_firmware_author", "")

        # Indicate that the entire partition can be cleared
        trim(${ROOTFS_B_PART_OFFSET}, ${ROOTFS_PART_COUNT})
    }

    on-resource fitImage {
        fat_write(${BOOT_PART_OFFSET}, "fitImage_B")
    }

    on-resource rootfs.img {
        raw_write(${ROOTFS_B_PART_OFFSET})
    }

    on-finish {
        uboot_setenv(uboot-env, "systemb_firmware_uuid", "\${FWUP_META_UUID}")
        uboot_setenv(uboot-env, "systemb_firmware_version", ${GRISP_FW_VERSION})
        uboot_setenv(uboot-env, "systemb_firmware_vcs_id", ${GRISP_FW_VCS_IDENTIFIER})
        uboot_setenv(uboot-env, "systemb_firmware_author", ${GRISP_FW_AUTHOR})
        uboot_setenv(uboot-env, "bootcount", "0")
        uboot_setenv(uboot-env, "upgrade_available", "1")
        uboot_setenv(uboot-env, "upgrade_fallback", "0")
        info("System B upgraded")
    }

    on-error {
    }
}

# This task handles unexpected active partition states
task upgrade.unexpected {
    require-uboot-variable(uboot-env, "alloy_env_ver", ${ALLOY_ENV_VER})
    require-uboot-variable(uboot-env, "system_platform", ${GRISP_FW_PLATFORM})
    require-uboot-variable(uboot-env, "system_architecture", ${GRISP_FW_ARCHITECTURE})
    on-init {
         error("Current system is not validated, or neither system A or B is active.")
    }
}

# This task handles env_ver/platform/architecture mismatches
task upgrade.wrongplatform {
    on-init {
        error("Expecting alloy_env_ver=${ALLOY_ENV_VER}, platform=${GRISP_FW_PLATFORM} and architecture=${GRISP_FW_ARCHITECTURE}")
    }
}

# Utility task to validate the current system
task validate.a {
    # Verify environment version compatibility
    require-uboot-variable(uboot-env, "alloy_env_ver", "${ALLOY_ENV_VER}")

    # Verify the expected platform/architecture
    require-uboot-variable(uboot-env, "system_platform", "${GRISP_FW_PLATFORM}")
    require-uboot-variable(uboot-env, "system_architecture", "${GRISP_FW_ARCHITECTURE}")

    # Verify we are running from system A
    require-path-at-offset("/", ${ROOTFS_A_PART_OFFSET})

    # Verify that partition A is currently active
    require-uboot-variable(uboot-env, "active_system", "a")

    # Ensure there is something to validate
    require-uboot-variable(uboot-env, "upgrade_available", "1")

    on-init {
        info("Validating system A")
        uboot_setenv(uboot-env, "upgrade_available", "0")
        uboot_setenv(uboot-env, "upgrade_fallback", "0")
        uboot_setenv(uboot-env, "valid_system", "a")
        uboot_setenv(uboot-env, "bootcount", "0")
        # Enable rollback after successful validation
        uboot_setenv(uboot-env, "rollback_available", "1")
    }

    on-finish {
        info("System A validated")
    }
}

task validate.b {
    # Verify environment version compatibility
    require-uboot-variable(uboot-env, "alloy_env_ver", "${ALLOY_ENV_VER}")

    # Verify the expected platform/architecture
    require-uboot-variable(uboot-env, "system_platform", "${GRISP_FW_PLATFORM}")
    require-uboot-variable(uboot-env, "system_architecture", "${GRISP_FW_ARCHITECTURE}")

    # Verify we are running from system B
    require-path-at-offset("/", ${ROOTFS_B_PART_OFFSET})

    # Verify that partition B is currently active
    require-uboot-variable(uboot-env, "active_system", "b")

    # Ensure there is something to validate
    require-uboot-variable(uboot-env, "upgrade_available", "1")

    on-init {
        info("Validating system B")
        uboot_setenv(uboot-env, "upgrade_available", "0")
        uboot_setenv(uboot-env, "upgrade_fallback", "0")
        uboot_setenv(uboot-env, "valid_system", "b")
        uboot_setenv(uboot-env, "bootcount", "0")
        # Enable rollback after successful validation
        uboot_setenv(uboot-env, "rollback_available", "1")
    }

    on-finish {
        info("System B validated")
    }
}

# This task handles validation attempts when no upgrade is pending
task validate.unavailable {
    require-uboot-variable(uboot-env, "alloy_env_ver", ${ALLOY_ENV_VER})
    require-uboot-variable(uboot-env, "system_platform", ${GRISP_FW_PLATFORM})
    require-uboot-variable(uboot-env, "system_architecture", ${GRISP_FW_ARCHITECTURE})
    on-init {
        error("No upgrade pending: nothing to validate.")
    }
}

# This task handles env_ver/platform/architecture mismatches
task validate.wrongplatform {
    on-init {
        error("Expecting alloy_env_ver=${ALLOY_ENV_VER}, platform=${GRISP_FW_PLATFORM} and architecture=${GRISP_FW_ARCHITECTURE}")
    }
}

# Rollback to system A (currently running from B)
task rollback.a {
    # Verify environment version compatibility
    require-uboot-variable(uboot-env, "alloy_env_ver", "${ALLOY_ENV_VER}")

    # Verify the expected platform/architecture
    require-uboot-variable(uboot-env, "system_platform", "${GRISP_FW_PLATFORM}")
    require-uboot-variable(uboot-env, "system_architecture", "${GRISP_FW_ARCHITECTURE}")

    # Verify we are running from system B
    require-path-at-offset("/", ${ROOTFS_B_PART_OFFSET})

    # Verify that partition B is currently active
    require-uboot-variable(uboot-env, "active_system", "b")

    # Require rollback to be allowed and no pending upgrade
    require-uboot-variable(uboot-env, "rollback_available", "1")
    require-uboot-variable(uboot-env, "upgrade_available", "0")

    on-init {
        info("Rolling back to system A (currently running from B)")

        # Select system A for next boot
        uboot_setenv(uboot-env, "valid_system", "a")

        # Reset counters/flags so normal boot path selects valid_system
        uboot_setenv(uboot-env, "bootcount", "0")
        uboot_setenv(uboot-env, "upgrade_available", "0")
        uboot_setenv(uboot-env, "upgrade_fallback", "0")

        # Reset system B metadata to empty values
        uboot_setenv(uboot-env, "systemb_firmware_uuid", "")
        uboot_setenv(uboot-env, "systemb_firmware_version", "")
        uboot_setenv(uboot-env, "systemb_firmware_vcs_id", "")
        uboot_setenv(uboot-env, "systemb_firmware_author", "")

        # Make rollback one-shot until next successful validation
        uboot_setenv(uboot-env, "rollback_available", "0")
    }
}

# Rollback to system B (currently running from A)
task rollback.b {
    # Verify environment version compatibility
    require-uboot-variable(uboot-env, "alloy_env_ver", "${ALLOY_ENV_VER}")

    # Verify the expected platform/architecture
    require-uboot-variable(uboot-env, "system_platform", "${GRISP_FW_PLATFORM}")
    require-uboot-variable(uboot-env, "system_architecture", "${GRISP_FW_ARCHITECTURE}")

    # Verify we are running from system A
    require-path-at-offset("/", ${ROOTFS_A_PART_OFFSET})

    # Verify that partition A is currently active
    require-uboot-variable(uboot-env, "active_system", "a")

    # Require rollback to be allowed and no pending upgrade
    require-uboot-variable(uboot-env, "rollback_available", "1")
    require-uboot-variable(uboot-env, "upgrade_available", "0")

    on-init {
        info("Rolling back to system B (currently running from A)")

        # Select system B for next boot
        uboot_setenv(uboot-env, "valid_system", "b")

        # Reset counters/flags so normal boot path selects valid_system
        uboot_setenv(uboot-env, "bootcount", "0")
        uboot_setenv(uboot-env, "upgrade_available", "0")
        uboot_setenv(uboot-env, "upgrade_fallback", "0")

        # Reset system A metadata to empty values
        uboot_setenv(uboot-env, "systema_firmware_uuid", "")
        uboot_setenv(uboot-env, "systema_firmware_version", "")
        uboot_setenv(uboot-env, "systema_firmware_vcs_id", "")
        uboot_setenv(uboot-env, "systema_firmware_author", "")

        # Make rollback one-shot until next successful validation
        uboot_setenv(uboot-env, "rollback_available", "0")
    }
}

# This task handles rollback when it's not available/safe
task rollback.unavailable {
    require-uboot-variable(uboot-env, "alloy_env_ver", ${ALLOY_ENV_VER})
    require-uboot-variable(uboot-env, "system_platform", ${GRISP_FW_PLATFORM})
    require-uboot-variable(uboot-env, "system_architecture", ${GRISP_FW_ARCHITECTURE})
    on-init {
        error("Rollback is not available or safe in the current state.")
    }
}

# This task handles env_ver/platform/architecture mismatches
task rollback.wrongplatform {
    on-init {
        error("Expecting alloy_env_ver=${ALLOY_ENV_VER}, platform=${GRISP_FW_PLATFORM} and architecture=${GRISP_FW_ARCHITECTURE}")
    }
}

# Print current update/boot state
# Validated, no rollback available
task status.a.validated_no_rollback {
    # Running A
    require-uboot-variable(uboot-env, "alloy_env_ver", "${ALLOY_ENV_VER}")
    require-path-at-offset("/", ${ROOTFS_A_PART_OFFSET})
    require-uboot-variable(uboot-env, "active_system", "a")
    require-uboot-variable(uboot-env, "valid_system", "a")
    require-uboot-variable(uboot-env, "upgrade_available", "0")
    require-uboot-variable(uboot-env, "rollback_available", "0")
    on-init {
        info("Status: Active=A, state=validated, reboot_needed=no, validation_needed=no, rollback_available=no")
    }
}

task status.b.validated_no_rollback {
    # Running B
    require-uboot-variable(uboot-env, "alloy_env_ver", "${ALLOY_ENV_VER}")
    require-path-at-offset("/", ${ROOTFS_B_PART_OFFSET})
    require-uboot-variable(uboot-env, "active_system", "b")
    require-uboot-variable(uboot-env, "valid_system", "b")
    require-uboot-variable(uboot-env, "upgrade_available", "0")
    require-uboot-variable(uboot-env, "rollback_available", "0")
    on-init {
        info("Status: Active=B, state=validated, reboot_needed=no, validation_needed=no, rollback_available=no")
    }
}

# Validated, rollback available
task status.a.validated_with_rollback {
    # Running A
    require-uboot-variable(uboot-env, "alloy_env_ver", "${ALLOY_ENV_VER}")
    require-path-at-offset("/", ${ROOTFS_A_PART_OFFSET})
    require-uboot-variable(uboot-env, "active_system", "a")
    require-uboot-variable(uboot-env, "upgrade_available", "0")
    require-uboot-variable(uboot-env, "rollback_available", "1")
    on-init {
        info("Status: Active=A, state=validated, reboot_needed=no, validation_needed=no, rollback_available=yes")
    }
}

task status.b.validated_with_rollback {
    # Running B
    require-uboot-variable(uboot-env, "alloy_env_ver", "${ALLOY_ENV_VER}")
    require-path-at-offset("/", ${ROOTFS_B_PART_OFFSET})
    require-uboot-variable(uboot-env, "active_system", "b")
    require-uboot-variable(uboot-env, "upgrade_available", "0")
    require-uboot-variable(uboot-env, "rollback_available", "1")
    on-init {
        info("Status: Active=B, state=validated, reboot_needed=no, validation_needed=no, rollback_available=yes")
    }
}

# Upgrade prepared but not yet booted into new system
task status.a.upgrading {
    # Running A
    require-uboot-variable(uboot-env, "alloy_env_ver", "${ALLOY_ENV_VER}")
    require-path-at-offset("/", ${ROOTFS_A_PART_OFFSET})
    require-uboot-variable(uboot-env, "active_system", "a")
    require-uboot-variable(uboot-env, "upgrade_available", "1")
    require-uboot-variable(uboot-env, "valid_system", "a")
    on-init {
        info("Status: Active=A, state=pending-upgrade, reboot_needed=yes, validation_needed=pending-reboot, rollback_available=no")
    }
}

task status.b.upgrading {
    # Running B
    require-uboot-variable(uboot-env, "alloy_env_ver", "${ALLOY_ENV_VER}")
    require-path-at-offset("/", ${ROOTFS_B_PART_OFFSET})
    require-uboot-variable(uboot-env, "active_system", "b")
    require-uboot-variable(uboot-env, "upgrade_available", "1")
    require-uboot-variable(uboot-env, "valid_system", "b")
    on-init {
        info("Status: Active=B, state=pending-upgrade, reboot_needed=yes, validation_needed=pending-reboot, rollback_available=no")
    }
}

# New system booted (pending validation)
task status.a.upgraded {
    # New Active=A (previous valid=B)
    require-uboot-variable(uboot-env, "alloy_env_ver", "${ALLOY_ENV_VER}")
    require-path-at-offset("/", ${ROOTFS_A_PART_OFFSET})
    require-uboot-variable(uboot-env, "active_system", "a")
    require-uboot-variable(uboot-env, "upgrade_available", "1")
    require-uboot-variable(uboot-env, "valid_system", "b")
    on-init {
        info("Status: Active=A, state=pending-validation, reboot_needed=no, validation_needed=yes, rollback_available=no")
    }
}

task status.b.upgraded {
    # New Active=B (previous valid=A)
    require-uboot-variable(uboot-env, "alloy_env_ver", "${ALLOY_ENV_VER}")
    require-path-at-offset("/", ${ROOTFS_B_PART_OFFSET})
    require-uboot-variable(uboot-env, "active_system", "b")
    require-uboot-variable(uboot-env, "upgrade_available", "1")
    require-uboot-variable(uboot-env, "valid_system", "a")
    on-init {
        info("Status: Active=B, state=pending-validation, reboot_needed=no, validation_needed=yes, rollback_available=no")
    }
}

# Rollback performed; reboot required to switch to the selected system
task status.a.rollback_pending_reboot {
    # Running A, but next boot will switch to B
    require-uboot-variable(uboot-env, "alloy_env_ver", "${ALLOY_ENV_VER}")
    require-path-at-offset("/", ${ROOTFS_A_PART_OFFSET})
    require-uboot-variable(uboot-env, "active_system", "a")
    require-uboot-variable(uboot-env, "upgrade_available", "0")
    require-uboot-variable(uboot-env, "valid_system", "b")
    on-init {
        info("Status: Active=A, state=pending-rollback, reboot_needed=yes, validation_needed=no, rollback_available=no")
    }
}

task status.b.rollback_pending_reboot {
    # Running B, but next boot will switch to A
    require-uboot-variable(uboot-env, "alloy_env_ver", "${ALLOY_ENV_VER}")
    require-path-at-offset("/", ${ROOTFS_B_PART_OFFSET})
    require-uboot-variable(uboot-env, "active_system", "b")
    require-uboot-variable(uboot-env, "upgrade_available", "0")
    require-uboot-variable(uboot-env, "valid_system", "a")
    on-init {
        info("Status: Active=B, state=pending-rollback, reboot_needed=yes, validation_needed=no, rollback_available=no")
    }
}

# Environment version mismatch status
task status.wrongenv {
    on-init {
        error("Expecting alloy_env_ver=${ALLOY_ENV_VER}")
    }
}
