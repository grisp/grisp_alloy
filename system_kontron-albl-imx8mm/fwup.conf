# WIP

# Firmware configuration file for Kontron i.MX8MM on Linux

require-fwup-version="1.0.0"

#
# Firmware metadata
#

# All of these can be overriden using environment variables of the same name.
#
#  Run 'fwup -m' to query values in a .fw file.
#  Use 'fw_printenv' to query values on the target.
#
# These are used by Grisp libraries to introspect.
define(GRISP_FW_PRODUCT, "Kontron AL/BL i.MX8M Mini Firmware")
define(GRISP_FW_DESCRIPTION, "")
define(GRISP_FW_VERSION, "")
define(GRISP_FW_PLATFORM, "kontron-albl-imx8mm")
define(GRISP_FW_ARCHITECTURE, "aarch64-unknown-linux-gnu")
define(GRISP_FW_AUTHOR, "Peer Stritzinger GmbH")
define(GRISP_FW_VCS_IDENTIFIER, "")

define(GRISP_FW_DEVPATH, "/dev/mmcblk1")
define(GRISP_FW_APPLICATION_PART0_DEVPATH, "/dev/mmcblk1p4") # Linux part number is 1-based
define(GRISP_FW_APPLICATION_PART0_FSTYPE, "f2fs")
define(GRISP_FW_APPLICATION_PART0_TARGET, "/root")
#define(GRISP_PROVISIONING, "${GRISP_TARGET_SYSTEM}/images/fwup_include/provisioning.conf")

# Default paths if not specified via the commandline
define(ROOTFS, "${GRISP_TARGET_SYSTEM}/images/rootfs.squashfs")
define(UBOOT, "${GRISP_SYSTEM}/images/flash.bin")
define(FITIMAGE, "${GRISP_SYSTEM}/images/fitImage")

# This configuration file will create an image that
# has an MBR and the following layout:
#
# +----------------------------+
# | MBR                        |
# +----------------------------+
# | U-Boot @ offset 33KB       |
# +----------------------------+
# | U-Boot Env 1 @ 1.875MB     |
# | U-Boot Env 2 @ 1.9375MB    |
# +----------------------------+
# | p0: Boot partition (FAT32) |
# | fitImage_A, fitImage_B     |
# +----------------------------+
# | p1: Rootfs A (squashfs)    |
# +----------------------------+
# | p2: Rootfs B (squashfs)    |
# +----------------------------+
# | p3: Application (f2fs)     |
# +----------------------------+

# The U-Boot is written directly to the SDCard/eMMC at 33KB offset (IMX_BOOT_SEEK)
define(UBOOT_OFFSET, 66)  # 33KB = 66 * 512 bytes blocks
define(UBOOT_COUNT, 8000) # Reserve ~4MB for U-Boot

# The U-Boot environment
# Dual environment setup for redundancy
define(UBOOT_ENV_PRIMARY_OFFSET, 3840)    # 1.875MB offset (0x1E0000)
define(UBOOT_ENV_SECONDARY_OFFSET, 3968)  # 1.9375MB offset (0x1F0000)
define(UBOOT_ENV_COUNT, 128)              # 64KB (0x10000)

# The boot partition contains the fitImage files for A/B boot
define(BOOT_PART_OFFSET, 8192)  # 4MB offset
define(BOOT_PART_COUNT, 131072) # 64MB

# Let the rootfs have room to grow up to 256MB and align it to the nearest 1MB boundary
define(ROOTFS_A_PART_OFFSET, 139264) # 4MB + 64MB = 68MB
define(ROOTFS_A_PART_COUNT, 524288)  # 256MB
define-eval(ROOTFS_B_PART_OFFSET, "${ROOTFS_A_PART_OFFSET} + ${ROOTFS_A_PART_COUNT}")
define(ROOTFS_B_PART_COUNT, ${ROOTFS_A_PART_COUNT})

# Application partition. This partition can occupy all of the remaining space.
# Size it to fit the destination.
define-eval(APP_PART_OFFSET, "${ROOTFS_B_PART_OFFSET} + ${ROOTFS_B_PART_COUNT}")
define(APP_PART_COUNT, 1048576)

# Firmware archive metadata
meta-product = ${GRISP_FW_PRODUCT}
meta-description = ${GRISP_FW_DESCRIPTION}
meta-version = ${GRISP_FW_VERSION}
meta-platform = ${GRISP_FW_PLATFORM}
meta-architecture = ${GRISP_FW_ARCHITECTURE}
meta-author = ${GRISP_FW_AUTHOR}
meta-vcs-identifier = ${GRISP_FW_VCS_IDENTIFIER}
meta-misc = ${GRISP_FW_MISC}

# File resources are listed in the order that they are included in the .fw file
# This is important, since this is the order that they're written on a firmware
# update due to the event driven nature of the update system.
file-resource uboot {
    host-path = ${UBOOT}
}

file-resource fitImage {
    host-path = ${FITIMAGE}
}
file-resource rootfs.img {
    host-path = ${ROOTFS}

    # Error out if the rootfs size exceeds the partition size
    assert-size-lte = ${ROOTFS_A_PART_COUNT}
}

mbr mbr {
    partition 0 {
        block-offset = ${BOOT_PART_OFFSET}
        block-count = ${BOOT_PART_COUNT}
        type = 0xc # FAT32
        boot = true
    }
    partition 1 {
        block-offset = ${ROOTFS_A_PART_OFFSET}
        block-count = ${ROOTFS_A_PART_COUNT}
        type = 0x83 # Linux
    }
    partition 2 {
        block-offset = ${ROOTFS_B_PART_OFFSET}
        block-count = ${ROOTFS_B_PART_COUNT}
        type = 0x83 # Linux
    }
    partition 3 {
        block-offset = ${APP_PART_OFFSET}
        block-count = ${APP_PART_COUNT}
        type = 0x83 # Linux
        expand = true
    }
}

uboot-environment uboot_env {
    block-offset = ${UBOOT_ENV_PRIMARY_OFFSET}
    block-offset-redund = ${UBOOT_ENV_SECONDARY_OFFSET}
    block-count = ${UBOOT_ENV_COUNT}
}

# This firmware task writes everything to the destination media.
# This should only be run at the factory to initialize a board!
task complete {
    # Only match if not mounted
    require-unmounted-destination = true

    on-init {
        info("Creating bootable eMMC image for Kontron i.MX8MM")
        mbr_write(mbr)

        fat_mkfs(${BOOT_PART_OFFSET}, ${BOOT_PART_COUNT})
        fat_setlabel(${BOOT_PART_OFFSET}, "BOOT")

        # Initialize U-Boot environment for A/B boot
        uboot_clearenv(uboot_env)
        uboot_setenv(uboot_env, "active_part", "a")
        uboot_setenv(uboot_env, "upgrade_available", "0")
        uboot_setenv(uboot_env, "bootcount", "0")
        uboot_setenv(uboot_env, "image_base", "fitImage")

        # Kernel parameters with single CPU RT isolation
        # CPU 3 isolated for RT, CPUs 0-2 available for normal system tasks
        uboot_setenv(uboot_env, "bootargs_base", "rootwait console=ttymxc2,115200 isolcpus=3 nohz_full=3 rcu_nocbs=3 rcu_nocb_poll intel_idle.max_cstate=1 processor.max_cstate=1")
    }

    on-resource uboot {
        # Write U-Boot at 33KB offset (no partition table)
        raw_write(${UBOOT_OFFSET})
    }

    on-resource fitImage {
        # Write initial fitImage to both A and B slots
        fat_write(${BOOT_PART_OFFSET}, "fitImage_A")
        fat_cp(${BOOT_PART_OFFSET}, "fitImage_A", "fitImage_B")
    }

    on-resource rootfs.img {
        # write to the first rootfs partition
        raw_write(${ROOTFS_A_PART_OFFSET})
    }

    on-finish {
        # Clear out any old data in the B partition that might be mistaken for
        # a file system. This is mostly to avoid confusion in humans when
        # reprogramming SDCards with unknown contents.
        raw_memset(${ROOTFS_B_PART_OFFSET}, 256, 0xff)

        # Invalidate the application data partition so that it is guaranteed to
        # trigger the corrupt filesystem detection code on first boot and get
        # formatted. If this isn't done and an old SDCard is reused, the
        # application data could be in a weird state.
        raw_memset(${APP_PART_OFFSET}, 256, 0xff)
    }
}

# This firmware task creates a bootable SD card from a host PC
# Use this for burning SD cards for development/production
task sdcard {
    # Ensure we're writing to an unmounted device
    require-unmounted-destination = true

    on-init {
        info("Creating bootable SD card for Kontron i.MX8MM")

        # Write partition table
        mbr_write(mbr)

        # Create and setup boot partition
        fat_mkfs(${BOOT_PART_OFFSET}, ${BOOT_PART_COUNT})
        fat_setlabel(${BOOT_PART_OFFSET}, "BOOT")

        # Initialize U-Boot environment for first boot
        uboot_clearenv(uboot_env)
        uboot_setenv(uboot_env, "active_part", "a")
        uboot_setenv(uboot_env, "upgrade_available", "0")
        uboot_setenv(uboot_env, "bootcount", "0")
        uboot_setenv(uboot_env, "image_base", "fitImage")

        # Kernel parameters with single CPU RT isolation
        # CPU 3 isolated for RT, CPUs 0-2 available for normal system tasks
        # This follows meta-ked-bsp pattern where bootargs_base contains the core parameters
        # that get combined with root= device path during boot
        uboot_setenv(uboot_env, "bootargs_base", "rootwait console=ttymxc2,115200 isolcpus=3 nohz_full=3 rcu_nocbs=3 rcu_nocb_poll intel_idle.max_cstate=1 processor.max_cstate=1")

        # Additional environment variables for SD card boot
        uboot_setenv(uboot_env, "bootdelay", "3")
        uboot_setenv(uboot_env, "vendor_boot_targets", "mmc0 mmc1")
        uboot_setenv(uboot_env, "bootcmd", "run vendor_bootcmd")
    }

    on-resource uboot {
        info("Writing U-Boot bootloader")
        # Write U-Boot at 33KB offset (required by i.MX8MM boot ROM)
        raw_write(${UBOOT_OFFSET})
    }

    on-resource fitImage {
        info("Writing FIT image")
        # Write fitImage to A slot only
        fat_write(${BOOT_PART_OFFSET}, "fitImage_A")
    }

    on-resource rootfs.img {
        info("Writing root filesystem to partition A")
        # Write rootfs to partition A (active partition)
        raw_write(${ROOTFS_A_PART_OFFSET})
    }

    on-finish {
        info("Finalizing SD card")

        # Format the application partition as F2FS
        # Note: This creates a filesystem signature that will be detected on first boot
        # The actual formatting will be done by the system on first boot
        raw_memset(${APP_PART_OFFSET}, 256, 0xff)

        info("SD card creation complete")
        info("Device path: ${GRISP_FW_DEVPATH}")
        info("Active partition: A (/dev/mmcblk1p2)")
        info("Boot from: fitImage_A")
    }
}

# This firmware task upgrades when partition B is currently active
task upgrade.a {
    # Verify that partition B is currently active
    require-uboot-variable(uboot_env, "active_part", "b")

    # Upgrade to partition A
    on-init {
        info("Upgrading partition A (currently running from B)")

        # Set that an upgrade is available
        uboot_setenv(uboot_env, "upgrade_available", "1")

        # Indicate that the entire partition can be cleared
        trim(${ROOTFS_A_PART_OFFSET}, ${ROOTFS_A_PART_COUNT})
    }

    # NOTE: U-Boot bootloader is NOT updated during upgrades for safety
    # Only complete installations should update the bootloader

    on-resource fitImage {
        fat_write(${BOOT_PART_OFFSET}, "fitImage_A")
    }

    on-resource rootfs.img {
        raw_write(${ROOTFS_A_PART_OFFSET})
    }

    on-finish {
        # Switch to partition A on next boot
        uboot_setenv(uboot_env, "active_part", "a")
    }

    on-error {
        # Reset upgrade flag on error
        uboot_setenv(uboot_env, "upgrade_available", "0")
    }
}

# This firmware task upgrades when partition A is currently active
task upgrade.b {
    # Verify that partition A is currently active
    require-uboot-variable(uboot_env, "active_part", "a")

    # Upgrade to partition B
    on-init {
        info("Upgrading partition B (currently running from A)")

        # Set that an upgrade is available
        uboot_setenv(uboot_env, "upgrade_available", "1")

        # Indicate that the entire partition can be cleared
        trim(${ROOTFS_B_PART_OFFSET}, ${ROOTFS_B_PART_COUNT})
    }

    # NOTE: U-Boot bootloader is NOT updated during upgrades for safety
    # Only complete installations should update the bootloader

    on-resource fitImage {
        fat_write(${BOOT_PART_OFFSET}, "fitImage_B")
    }

    on-resource rootfs.img {
        raw_write(${ROOTFS_B_PART_OFFSET})
    }

    on-finish {
        # Switch to partition B on next boot
        uboot_setenv(uboot_env, "active_part", "b")
    }

    on-error {
        # Reset upgrade flag on error
        uboot_setenv(uboot_env, "upgrade_available", "0")
    }
}

# This task handles unexpected active partition states
task upgrade.unexpected {
    # This task runs when active_part is not "a" or "b"
    on-init {
        error("Unexpected active partition: ${FWUP_TASK}")
        error("Expected active_part to be 'a' or 'b'")
        error("Please check the U-Boot environment and try again")
    }
}
