# Firmware configuration file for Kontron AL/BL i.MX8M Mini on Linux

require-fwup-version="1.4.0"

#
# Firmware metadata
#

# All of these can be overriden using environment variables of the same name.
#
#  Run 'fwup -m' to query values in a .fw file.
#  Use 'fw_printenv' to query values on the target.
#
define(GRISP_FW_PRODUCT, "Kontron AL/BL i.MX8M Mini Firmware")
define(GRISP_FW_DESCRIPTION, "")
define(GRISP_FW_VERSION, "")
define(GRISP_FW_PLATFORM, "kontron-albl-imx8mm")
define(GRISP_FW_ARCHITECTURE, "aarch64-unknown-linux-gnu")
define(GRISP_FW_AUTHOR, "Peer Stritzinger GmbH")
define(GRISP_FW_VCS_IDENTIFIER, "")
define(GRISP_FW_MISC, "")

# Default paths if not specified via the commandline
define(ROOTFS, "${GRISP_TARGET_SYSTEM}/images/rootfs.squashfs")
define(UBOOT, "${GRISP_SYSTEM}/images/flash.bin")
define(FITIMAGE, "${GRISP_SYSTEM}/images/fitImage")
define(PRIMARY_ENV_BIN, "${GRISP_SYSTEM}/images/uboot-env.bin")
define(SECONDARY_ENV_BIN, "${GRISP_SYSTEM}/images/uboot-env.bin")

# This configuration file will create an image that
# uses GPT and the following layout (partition numbers):
#
# +----------------------------------------+
# | Protective MBR + GPT                   |
# +----------------------------------------+
# | U-Boot @ offset 33KB (Only on SDCard)  |
# +----------------------------------------+
# | U-Boot Env 1 @ 1.875 MiB               |
# | U-Boot Env 2 @ 1.9375 MiB              |
# +----------------------------------------+
# | p0: Secure Enclave (Only on eMMC)      |
# +----------------------------------------+
# | p1: Boot (FAT32)                       |
# |     fitImage_A/B (On eMMC)             |
# |     fitImage     (On SDCard)           |
# +----------------------------------------+
# | p2: Rootfs A (squashfs)                |
# +----------------------------------------+
# | p3: Rootfs B (squashfs) (Only on eMMC) |
# +----------------------------------------+
# | p4: Application (f2fs)                 |
# +----------------------------------------+

# The U-Boot is written directly to the SDCard/eMMC at 33 KiB offset (IMX_BOOT_SEEK)
define(FLASH_UBOOT_OFFSET, 2)  # 1 KiB = 2 * 512 bytes blocks
define(SDCARD_UBOOT_OFFSET, 66)  # 33 KiB = 66 * 512 bytes blocks
# The max size take into account both the flash and the sdcard,
# the bootloader starting at 33 KiB offset on sdcard means the bootloader maximum
# size is 32 KiB lower than what the flash would support.
define(UBOOT_MAX_SIZE, 3774)  # 0x1E0000 - 33 KiB / 512

# The U-Boot environment on the both SDCard and Flash
# Dual environment setup for redundancy
define(UBOOT_ENV_PRIMARY_OFFSET, 3840)    # 1.875 MiB offset (0x1E0000)
define(UBOOT_ENV_SECONDARY_OFFSET, 3968)  # 1.9375 MiB offset (0x1F0000)
define(UBOOT_ENV_COUNT, 128)              # 64 KiB (0x10000)

# Partition sizes
define(DUMMY_PART_COUNT, 2048)     # 1 MiB
define(SEC_PART_COUNT, 262144)     # 128 MiB
define(BOOT_PART_COUNT, 131072)    # 64 MiB
define(ROOTFS_PART_COUNT, 524288)  # 256 MiB
define(APP_PART_COUNT, 1048576)    # 512 MiB


# eMMC partition offsets

# Reserve space for a future secure enclave at 4 MiB (before other partitions)
define(EMMC_SEC_PART_OFFSET, 8192)   # 4 MiB

# The boot partition contains the fitImage files for A/B boot
define-eval(EMMC_BOOT_PART_OFFSET, "${EMMC_SEC_PART_OFFSET} + ${SEC_PART_COUNT}")

# Let the rootfs have room to grow up to 256 MiB and align it to the nearest 1 MiB boundary
define-eval(EMMC_ROOTFS_A_PART_OFFSET, "${EMMC_BOOT_PART_OFFSET} + ${BOOT_PART_COUNT}")
define-eval(EMMC_ROOTFS_B_PART_OFFSET, "${EMMC_ROOTFS_A_PART_OFFSET} + ${ROOTFS_PART_COUNT}")

# Application partition. This partition can occupy all of the remaining space.
# Size it to fit the destination.
define-eval(EMMC_APP_PART_OFFSET, "${EMMC_ROOTFS_B_PART_OFFSET} + ${ROOTFS_PART_COUNT}")


# SDCard partition offsets

# Dummy partition to keep the layout consistent
define(SDCARD_DUMMY1_PART_OFFSET, 8192)   # 4 MiB

# The boot partition contains the fitImage files for A/B boot
define-eval(SDCARD_BOOT_PART_OFFSET, "${SDCARD_DUMMY1_PART_OFFSET} + ${DUMMY_PART_COUNT}")

# Let the rootfs have room to grow up to 256 MiB and align it to the nearest 1 MiB boundary
define-eval(SDCARD_ROOTFS_PART_OFFSET, "${SDCARD_BOOT_PART_OFFSET} + ${BOOT_PART_COUNT}")

# No second rootfs partition on SDCard
define-eval(SDCARD_DUMMY2_PART_OFFSET, "${SDCARD_ROOTFS_PART_OFFSET} + ${ROOTFS_PART_COUNT}")

# Application partition. This partition can occupy all of the remaining space.
# Size it to fit the destination.
define-eval(SDCARD_APP_PART_OFFSET, "${SDCARD_DUMMY2_PART_OFFSET} + ${DUMMY_PART_COUNT}")


# Firmware archive metadata
meta-product = ${GRISP_FW_PRODUCT}
meta-description = ${GRISP_FW_DESCRIPTION}
meta-version = ${GRISP_FW_VERSION}
meta-platform = ${GRISP_FW_PLATFORM}
meta-architecture = ${GRISP_FW_ARCHITECTURE}
meta-author = ${GRISP_FW_AUTHOR}
meta-vcs-identifier = ${GRISP_FW_VCS_IDENTIFIER}
meta-misc = ${GRISP_FW_MISC}

# File resources are listed in the order that they are included in the .fw file
# This is important, since this is the order that they're written on a firmware
# upgrade due to the event driven nature of the update system.
file-resource uboot {
    host-path = ${UBOOT}
    assert-size-lte = ${UBOOT_MAX_SIZE}
}

file-resource primary-uboot-env {
    host-path = ${PRIMARY_ENV_BIN}
    assert-size-lte = ${UBOOT_ENV_COUNT}
}

file-resource secondary-uboot-env {
    host-path = ${SECONDARY_ENV_BIN}
    assert-size-lte = ${UBOOT_ENV_COUNT}
}

file-resource fitImage {
    host-path = ${FITIMAGE}
}

file-resource rootfs.img {
    host-path = ${ROOTFS}

    # Error out if the rootfs size exceeds the partition size
    assert-size-lte = ${ROOTFS_PART_COUNT}
}

gpt gpt-emmc {
    guid = 01999b2e-3fba-7508-9cd5-a58f16f5350a

    partition 0 {
        block-offset = ${EMMC_SEC_PART_OFFSET}
        block-count = ${SEC_PART_COUNT}
        type = 8da63339-0007-60c0-c436-083ac8230908  # Linux reserved
        guid = 01999b27-85c6-727c-a37b-c1838a5c93fa
        name = "secure_enclave"
    }
    partition 1 {
        block-offset = ${EMMC_BOOT_PART_OFFSET}
        block-count = ${BOOT_PART_COUNT}
        type = ebd0a0a2-b9e5-4433-87c0-68b6b72699c7  # Basic data (FAT)
        guid = 01999b27-ae3e-77eb-bc96-2b5da0810af8
        name = "boot"
    }
    partition 2 {
        block-offset = ${EMMC_ROOTFS_A_PART_OFFSET}
        block-count = ${ROOTFS_PART_COUNT}
        type = 0fc63daf-8483-4772-8e79-3d69d8477de4  # Linux filesystem
        guid = 01999b27-e0ca-73cf-9908-d9d1961a7df0
        name = "rootfs_a"
    }
    partition 3 {
        block-offset = ${EMMC_ROOTFS_B_PART_OFFSET}
        block-count = ${ROOTFS_PART_COUNT}
        type = 0fc63daf-8483-4772-8e79-3d69d8477de4  # Linux filesystem
        guid = 01999b27-fffa-74af-9f51-aafad27e9e88
        name = "rootfs_b"
    }
    partition 4 {
        block-offset = ${EMMC_APP_PART_OFFSET}
        block-count = ${APP_PART_COUNT}
        type = 0fc63daf-8483-4772-8e79-3d69d8477de4  # Linux filesystem
        guid = 01999b28-1b5a-738e-9a47-649cf192b781
        name = "data"
        expand = true
    }
}

gpt gpt-sdcard {
    guid = 0199a9b9-b69a-73bd-bbfc-224a78218c22

    partition 0 {
        block-offset = ${SDCARD_DUMMY1_PART_OFFSET}
        block-count = ${DUMMY_PART_COUNT}
        type = 8da63339-0007-60c0-c436-083ac8230908  # Linux reserved
        guid = 0199a9cc-e7d9-726e-865c-390a61d8f665
        name = "reserved"
    }
    partition 1 {
        block-offset = ${SDCARD_BOOT_PART_OFFSET}
        block-count = ${BOOT_PART_COUNT}
        type = ebd0a0a2-b9e5-4433-87c0-68b6b72699c7  # Basic data (FAT)
        guid = 01999b27-ae3e-77eb-bc96-2b5da0810af8
        name = "boot"
    }
    partition 2 {
        block-offset = ${SDCARD_ROOTFS_PART_OFFSET}
        block-count = ${ROOTFS_PART_COUNT}
        type = 0fc63daf-8483-4772-8e79-3d69d8477de4  # Linux filesystem
        guid = 0199a9ba-b60d-716c-8b5e-4fa9a3865b11
        name = "rootfs"
    }
    partition 3 {
        block-offset = ${SDCARD_DUMMY2_PART_OFFSET}
        block-count = ${DUMMY_PART_COUNT}
        type = 8da63339-0007-60c0-c436-083ac8230908 # Linux reserved
        guid = 0199a9ce-d6e5-723f-a353-5f5712008ff4
        name = "reserved"
    }
    partition 4 {
        block-offset = ${SDCARD_APP_PART_OFFSET}
        block-count = ${APP_PART_COUNT}
        type = 0fc63daf-8483-4772-8e79-3d69d8477de4  # Linux filesystem
        guid = 01999b28-1b5a-738e-9a47-649cf192b781
        name = "data"
        expand = true
    }
}

uboot-environment uboot-env {
    block-offset = ${UBOOT_ENV_PRIMARY_OFFSET}
    block-offset-redund = ${UBOOT_ENV_SECONDARY_OFFSET}
    block-count = ${UBOOT_ENV_COUNT}
}

# This firmware task perform a factory reset of the board bootloader.
# This doesn't include the eMMC, use task bootloader for that.
# Should be performed on device /dev/mtd0 and --unsafe option is required
task bootloader {
    # Only match if not mounted
    require-unmounted-destination = true

    on-init {
        info("Starting Kontron AL/BL i.MX8M Mini bootloader initialization")
    }

    on-resource uboot {
        info("Flashing U-Boot bootloader...")
        # Erase the first 480 blocks of the flash
        # Erase size is 4 KiB, so it will erase up to 0x1E0000
        execute("flash_erase -q /dev/mtd0 0 480")
        pipe_write("dd of=/dev/mtd0 bs=512 seek=2 count=3838 conv=sync status=none")
    }

    on-finish {
        info("Bootloader initialization done")
    }
}

# This firmware task perform a factory reset of the eMMC.
# This doesn't include the bootloader and boot environemnt, use task bootloader for that.
# The uboot environment cannot be used, as it resides on the flash partition.
# Should be performed on device /dev/mmcblk0
task emmc {
    # Only match if not mounted
    require-unmounted-destination = true

    on-init {
        info("Starting Kontron AL/BL i.MX8M Mini eMMC initialization")
        gpt_write(gpt-emmc)

        fat_mkfs(${EMMC_BOOT_PART_OFFSET}, ${BOOT_PART_COUNT})
        fat_setlabel(${EMMC_BOOT_PART_OFFSET}, "BOOT")

        # Clear out any old data in the rootfs partitions
        trim(${EMMC_ROOTFS_A_PART_OFFSET}, ${ROOTFS_PART_COUNT})
        trim(${EMMC_ROOTFS_B_PART_OFFSET}, ${ROOTFS_PART_COUNT})

        uboot_clearenv(uboot-env)
    }

    on-resource primary-uboot-env {
        info("Flashing U-Boot main environment...")
        raw_write(${UBOOT_ENV_PRIMARY_OFFSET})
    }

    on-resource secondary-uboot-env {
        info("Flashing U-Boot redundant environment...")
        raw_write(${UBOOT_ENV_SECONDARY_OFFSET})

        info("Customising U-Boot environment...")

        # Override/customize specific variables for factory initialization
        uboot_setenv(uboot-env, "valid_system", "a")
        uboot_setenv(uboot-env, "active_system", "a")
        uboot_setenv(uboot-env, "upgrade_available", "0")
        uboot_setenv(uboot-env, "upgrade_fallback", "0")

        # Initialize system A metadata
        uboot_setenv(uboot-env, "systema_firmware_uuid", "\${FWUP_META_UUID}")
        uboot_setenv(uboot-env, "systema_firmware_version", ${GRISP_FW_VERSION})
        uboot_setenv(uboot-env, "systema_firmware_vcs_id", ${GRISP_FW_VCS_IDENTIFIER})
        uboot_setenv(uboot-env, "systema_firmware_author", ${GRISP_FW_AUTHOR})

        # Add extra kernel parameters for RT isolation
        # CPU 3 isolated for RT, CPUs 0-2 available for normal system tasks
        uboot_setenv(uboot-env, "bootargs_extra", "isolcpus=3 nohz_full=3 rcu_nocbs=3 rcu_nocb_poll intel_idle.max_cstate=1 processor.max_cstate=1")
    }

    on-resource fitImage {
        info("Writing FIT image...")
        # Write initial fitImage for system A
        fat_write(${EMMC_BOOT_PART_OFFSET}, "fitImage_A")
        # Cleanup any old system B image
        fat_rm(${EMMC_BOOT_PART_OFFSET}, "fitImage_B")
    }

    on-resource rootfs.img {
        info("Writing root filesystem to partition A...")
        # write to the first rootfs partition
        raw_write(${EMMC_ROOTFS_A_PART_OFFSET})
    }

    on-finish {
        info("Finalizing eMMC firmware...")

        # Invalidate the application data partition so that it is guaranteed to
        # trigger the corrupt filesystem detection code on first boot and get
        # formatted.
        raw_memset(${EMMC_APP_PART_OFFSET}, 256, 0xff)

        info("eMMC initialization done")
    }
}

# This firmware task creates a bootable SD card from a host PC
# Use this for burning SD cards for development/production
task sdcard {
    # Ensure we're writing to an unmounted device
    require-unmounted-destination = true

    on-init {
        info("Starting creation of bootable SD card for Kontron AL/BL i.MX8M Mini")

        # Write partition table
        gpt_write(gpt-sdcard)

        # Create and setup boot partition
        fat_mkfs(${SDCARD_BOOT_PART_OFFSET}, ${BOOT_PART_COUNT})
        fat_setlabel(${SDCARD_BOOT_PART_OFFSET}, "BOOT")

        uboot_clearenv(uboot-env)
    }

    on-resource uboot {
        info("Writing U-Boot bootloader...")
        # Write U-Boot at 33KB offset (required by i.MX8MM boot ROM)
        raw_write(${SDCARD_UBOOT_OFFSET})
    }

    on-resource primary-uboot-env {
        info("Writing U-Boot main environment...")
        raw_write(${UBOOT_ENV_PRIMARY_OFFSET})
    }

    on-resource secondary-uboot-env {
        info("Writing U-Boot redundant environment...")
        raw_write(${UBOOT_ENV_SECONDARY_OFFSET})

        info("Customising U-Boot environment...")

        # Override/customize specific variables for factory initialization
        uboot_setenv(uboot-env, "valid_system", "a")
        uboot_setenv(uboot-env, "active_system", "a")
        uboot_setenv(uboot-env, "upgrade_available", "0")
        uboot_setenv(uboot-env, "upgrade_fallback", "0")

        # Initialize system A metadata
        uboot_setenv(uboot-env, "systema_firmware_uuid", "\${FWUP_META_UUID}")
        uboot_setenv(uboot-env, "systema_firmware_version", ${GRISP_FW_VERSION})
        uboot_setenv(uboot-env, "systema_firmware_vcs_id", ${GRISP_FW_VCS_IDENTIFIER})
        uboot_setenv(uboot-env, "systema_firmware_author", ${GRISP_FW_AUTHOR})

        # Add extra kernel parameters for RT isolation
        # CPU 3 isolated for RT, CPUs 0-2 available for normal system tasks
        uboot_setenv(uboot-env, "bootargs_extra", "isolcpus=3 nohz_full=3 rcu_nocbs=3 rcu_nocb_poll intel_idle.max_cstate=1 processor.max_cstate=1")

        # Additional environment variables for SD card boot
        uboot_setenv(uboot-env, "bootdelay", "3")
    }

    on-resource fitImage {
        info("Writing FIT image")
        # Write fitImage to A slot only
        fat_write(${SDCARD_BOOT_PART_OFFSET}, "fitImage")
    }

    on-resource rootfs.img {
        info("Writing root filesystem to partition A")
        # Write rootfs to partition A (active partition)
        raw_write(${SDCARD_ROOTFS_PART_OFFSET})
    }

    on-finish {
        info("Finalizing SD card")

        # Invalidate the application data partition so that it is guaranteed to
        # trigger the corrupt filesystem detection code on first boot and get
        # formatted.
        raw_memset(${SDCARD_APP_PART_OFFSET}, 256, 0xff)

        info("SD card setup done")
    }
}

# This firmware task upgrades system A when system B is currently active
task upgrade.a {
    # Verify we are running from system B
    require-path-at-offset("/", ${EMMC_ROOTFS_B_PART_OFFSET})

    # Verify that partition B is currently active
    require-uboot-variable(uboot-env, "active_system", "b")

    # Verify the expected platform/architecture
    require-uboot-variable(uboot-env, "system_platform", "${GRISP_FW_PLATFORM}")
    require-uboot-variable(uboot-env, "system_architecture", "${GRISP_FW_ARCHITECTURE}")

    # Upgrade to partition A
    on-init {
        info("Upgrading system A (currently running from B)")

        # Any already upgraded system will be destroyed
        uboot_setenv(uboot-env, "upgrade_available", "0")

        # Override system A metadata
        uboot_setenv(uboot-env, "systema_firmware_uuid", "\${FWUP_META_UUID}")
        uboot_setenv(uboot-env, "systema_firmware_version", ${GRISP_FW_VERSION})
        uboot_setenv(uboot-env, "systema_firmware_vcs_id", ${GRISP_FW_VCS_IDENTIFIER})
        uboot_setenv(uboot-env, "systema_firmware_author", ${GRISP_FW_AUTHOR})

        # Indicate that the entire partition can be cleared
        trim(${EMMC_ROOTFS_A_PART_OFFSET}, ${ROOTFS_PART_COUNT})
    }

    on-resource fitImage {
        fat_write(${EMMC_BOOT_PART_OFFSET}, "fitImage_A")
    }

    on-resource rootfs.img {
        raw_write(${EMMC_ROOTFS_A_PART_OFFSET})
    }

    on-finish {
        uboot_setenv(uboot-env, "bootcount", "0")
        uboot_setenv(uboot-env, "upgrade_available", "1")
        uboot_setenv(uboot-env, "upgrade_fallback", "0")
        info("System A upgraded")
    }

    on-error {
    }
}

# This firmware task upgrades system B when system A is currently active
task upgrade.b {
    # Verify we are running from system A
    require-path-at-offset("/", ${EMMC_ROOTFS_A_PART_OFFSET})

    # Verify that partition A is currently active
    require-uboot-variable(uboot-env, "active_system", "a")

    # Verify the expected platform/architecture
    require-uboot-variable(uboot-env, "system_platform", "${GRISP_FW_PLATFORM}")
    require-uboot-variable(uboot-env, "system_architecture", "${GRISP_FW_ARCHITECTURE}")

    # Upgrade to partition B
    on-init {
        info("Upgrading system B (currently running from A)")

        # Any already upgraded system will be destroyed
        uboot_setenv(uboot-env, "upgrade_available", "0")

        # Override system B metadata
        uboot_setenv(uboot-env, "systemb_firmware_uuid", "\${FWUP_META_UUID}")
        uboot_setenv(uboot-env, "systemb_firmware_version", ${GRISP_FW_VERSION})
        uboot_setenv(uboot-env, "systemb_firmware_vcs_id", ${GRISP_FW_VCS_IDENTIFIER})
        uboot_setenv(uboot-env, "systemb_firmware_author", ${GRISP_FW_AUTHOR})

        # Indicate that the entire partition can be cleared
        trim(${EMMC_ROOTFS_B_PART_OFFSET}, ${ROOTFS_PART_COUNT})
    }

    on-resource fitImage {
        fat_write(${EMMC_BOOT_PART_OFFSET}, "fitImage_B")
    }

    on-resource rootfs.img {
        raw_write(${EMMC_ROOTFS_B_PART_OFFSET})
    }

    on-finish {
        uboot_setenv(uboot-env, "bootcount", "0")
        uboot_setenv(uboot-env, "upgrade_available", "1")
        uboot_setenv(uboot-env, "upgrade_fallback", "0")
        info("System B upgraded")
    }

    on-error {
    }
}

# This task handles unexpected active partition states
task upgrade.unexpected {
    require-uboot-variable(uboot-env, "system_platform", ${GRISP_FW_PLATFORM})
    require-uboot-variable(uboot-env, "system_architecture", ${GRISP_FW_ARCHITECTURE})
    on-init {
         error("It doesn't look like either the A or B systems are active.")
    }
}

# This task handles platform/architecture mismatches
task upgrade.wrongplatform {
    on-init {
        error("Expecting platform=${GRISP_FW_PLATFORM} and architecture=${GRISP_FW_ARCHITECTURE}")
    }
}

# Utility task to validate the current system
task validate.a {
    # Verify we are running from system A
    require-path-at-offset("/", ${EMMC_ROOTFS_A_PART_OFFSET})

    # Verify that partition A is currently active
    require-uboot-variable(uboot-env, "active_system", "a")

    # Verify the expected platform/architecture
    require-uboot-variable(uboot-env, "system_platform", "${GRISP_FW_PLATFORM}")
    require-uboot-variable(uboot-env, "system_architecture", "${GRISP_FW_ARCHITECTURE}")

    on-init {
        info("Validating system A")
        uboot_setenv(uboot-env, "upgrade_available", "0")
        uboot_setenv(uboot-env, "upgrade_fallback", "0")
        uboot_setenv(uboot-env, "valid_system", "a")
        uboot_setenv(uboot-env, "bootcount", "0")
    }

    on-finish {
        info("System A validated")
    }
}

task validate.b {
    # Verify we are running from system B
    require-path-at-offset("/", ${EMMC_ROOTFS_B_PART_OFFSET})

    # Verify that partition B is currently active
    require-uboot-variable(uboot-env, "active_system", "b")

    # Verify the expected platform/architecture
    require-uboot-variable(uboot-env, "system_platform", "${GRISP_FW_PLATFORM}")
    require-uboot-variable(uboot-env, "system_architecture", "${GRISP_FW_ARCHITECTURE}")

    on-init {
        info("Validating system B")
        uboot_setenv(uboot-env, "upgrade_available", "0")
        uboot_setenv(uboot-env, "upgrade_fallback", "0")
        uboot_setenv(uboot-env, "valid_system", "b")
        uboot_setenv(uboot-env, "bootcount", "0")
    }

    on-finish {
        info("System B validated")
    }
}
