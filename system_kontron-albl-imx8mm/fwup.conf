# Firmware configuration file for Kontron AL/BL i.MX8M Mini on Linux

require-fwup-version="1.0.0"

#
# Firmware metadata
#

# All of these can be overriden using environment variables of the same name.
#
#  Run 'fwup -m' to query values in a .fw file.
#  Use 'fw_printenv' to query values on the target.
#
define(GRISP_FW_PRODUCT, "Kontron AL/BL i.MX8M Mini Firmware")
define(GRISP_FW_DESCRIPTION, "")
define(GRISP_FW_VERSION, "")
define(GRISP_FW_PLATFORM, "kontron-albl-imx8mm")
define(GRISP_FW_ARCHITECTURE, "aarch64-unknown-linux-gnu")
define(GRISP_FW_AUTHOR, "Peer Stritzinger GmbH")
define(GRISP_FW_VCS_IDENTIFIER, "")

# Default paths if not specified via the commandline
define(ROOTFS, "${GRISP_TARGET_SYSTEM}/images/rootfs.squashfs")
define(UBOOT, "${GRISP_SYSTEM}/images/flash.bin")
define(FITIMAGE, "${GRISP_SYSTEM}/images/fitImage")
define(PRIMARY_ENV_BIN, "${GRISP_SYSTEM}/images/uboot-env.bin")
define(SECONDARY_ENV_BIN, "${GRISP_SYSTEM}/images/uboot-env.bin")

# This configuration file will create an image that
# has an MBR and the following layout:
#
# +----------------------------+
# | MBR                        |
# +----------------------------+
# | U-Boot @ offset 33KB       |
# +----------------------------+
# | U-Boot Env 1 @ 1.875MB     |
# | U-Boot Env 2 @ 1.9375MB    |
# +----------------------------+
# | p0: Boot partition (FAT32) |
# | fitImage_A, fitImage_B     |
# +----------------------------+
# | p1: Rootfs A (squashfs)    |
# +----------------------------+
# | p2: Rootfs B (squashfs)    |
# +----------------------------+
# | p3: Application (f2fs)     |
# +----------------------------+

# The U-Boot is written directly to the SDCard/eMMC at 33KB offset (IMX_BOOT_SEEK)
define(UBOOT_OFFSET, 66)  # 33KB = 66 * 512 bytes blocks
define(UBOOT_COUNT, 8000) # Reserve ~4MB for U-Boot

# The U-Boot environment
# Dual environment setup for redundancy
define(UBOOT_ENV_PRIMARY_OFFSET, 3840)    # 1.875MB offset (0x1E0000)
define(UBOOT_ENV_SECONDARY_OFFSET, 3968)  # 1.9375MB offset (0x1F0000)
define(UBOOT_ENV_COUNT, 128)              # 64KB (0x10000)

# The boot partition contains the fitImage files for A/B boot
define(BOOT_PART_OFFSET, 8192)  # 4MB offset
define(BOOT_PART_COUNT, 131072) # 64MB

# Let the rootfs have room to grow up to 256MB and align it to the nearest 1MB boundary
define(ROOTFS_A_PART_OFFSET, 139264) # 4MB + 64MB = 68MB
define(ROOTFS_A_PART_COUNT, 524288)  # 256MB
define-eval(ROOTFS_B_PART_OFFSET, "${ROOTFS_A_PART_OFFSET} + ${ROOTFS_A_PART_COUNT}")
define(ROOTFS_B_PART_COUNT, ${ROOTFS_A_PART_COUNT})

# Application partition. This partition can occupy all of the remaining space.
# Size it to fit the destination.
define-eval(APP_PART_OFFSET, "${ROOTFS_B_PART_OFFSET} + ${ROOTFS_B_PART_COUNT}")
define(APP_PART_COUNT, 1048576)

# Firmware archive metadata
meta-product = ${GRISP_FW_PRODUCT}
meta-description = ${GRISP_FW_DESCRIPTION}
meta-version = ${GRISP_FW_VERSION}
meta-platform = ${GRISP_FW_PLATFORM}
meta-architecture = ${GRISP_FW_ARCHITECTURE}
meta-author = ${GRISP_FW_AUTHOR}
meta-vcs-identifier = ${GRISP_FW_VCS_IDENTIFIER}
meta-misc = ${GRISP_FW_MISC}

# File resources are listed in the order that they are included in the .fw file
# This is important, since this is the order that they're written on a firmware
# update due to the event driven nature of the update system.
file-resource uboot {
    host-path = ${UBOOT}
}

file-resource primary-uboot-env {
    host-path = ${PRIMARY_ENV_BIN}
}

file-resource secondary-uboot-env {
    host-path = ${SECONDARY_ENV_BIN}
}

file-resource fitImage {
    host-path = ${FITIMAGE}
}

file-resource rootfs.img {
    host-path = ${ROOTFS}

    # Error out if the rootfs size exceeds the partition size
    assert-size-lte = ${ROOTFS_A_PART_COUNT}
}

mbr mbr {
    partition 0 {
        block-offset = ${BOOT_PART_OFFSET}
        block-count = ${BOOT_PART_COUNT}
        type = 0xc # FAT32
        boot = true
    }
    partition 1 {
        block-offset = ${ROOTFS_A_PART_OFFSET}
        block-count = ${ROOTFS_A_PART_COUNT}
        type = 0x83 # Linux
    }
    partition 2 {
        block-offset = ${ROOTFS_B_PART_OFFSET}
        block-count = ${ROOTFS_B_PART_COUNT}
        type = 0x83 # Linux
    }
    partition 3 {
        block-offset = ${APP_PART_OFFSET}
        block-count = ${APP_PART_COUNT}
        type = 0x83 # Linux
        expand = true
    }
}

uboot-environment uboot-env {
    block-offset = ${UBOOT_ENV_PRIMARY_OFFSET}
    block-offset-redund = ${UBOOT_ENV_SECONDARY_OFFSET}
    block-count = ${UBOOT_ENV_COUNT}
}

# This firmware task writes everything to the destination media.
# This should only be run at the factory to initialize a board!
task complete {
    # Only match if not mounted
    require-unmounted-destination = true

    on-init {
        info("Initializing Kontron AL/BL i.MX8M Mini eMMC")
        mbr_write(mbr)

        fat_mkfs(${BOOT_PART_OFFSET}, ${BOOT_PART_COUNT})
        fat_setlabel(${BOOT_PART_OFFSET}, "BOOT")

        uboot_clearenv(uboot-env)
    }

    on-resource uboot {
        info("Writing U-Boot bootloader")
        # Write U-Boot at 33KB offset (no partition table)
        raw_write(${UBOOT_OFFSET})
    }

    on-resource primary-uboot-env {
        info("Writing U-Boot main environment")
        raw_write(${UBOOT_ENV_PRIMARY_OFFSET})
    }

    on-resource secondary-uboot-env {
        info("Writing U-Boot redundant environment")
        raw_write(${UBOOT_ENV_SECONDARY_OFFSET})

        info("Customising U-Boot environment")

        # Override/customize specific variables for factory initialization
        uboot_setenv(uboot-env, "valid_system", "a")
        uboot_setenv(uboot-env, "active_system", "a")
        uboot_setenv(uboot-env, "update_available", "0")
        uboot_setenv(uboot-env, "update_fallback", "0")

        # Initialize system A metadata
        uboot_setenv(uboot-env, "systema_firmware_uuid", "\${FWUP_META_UUID}")
        uboot_setenv(uboot-env, "systema_firmware_version", ${GRISP_FW_VERSION})
        uboot_setenv(uboot-env, "systema_firmware_vcs_id", ${GRISP_FW_VCS_IDENTIFIER})
        uboot_setenv(uboot-env, "systema_firmware_author", ${GRISP_FW_AUTHOR})

        # Add extra kernel parameters for RT isolation
        # CPU 3 isolated for RT, CPUs 0-2 available for normal system tasks
        uboot_setenv(uboot-env, "bootargs_extra", "isolcpus=3 nohz_full=3 rcu_nocbs=3 rcu_nocb_poll intel_idle.max_cstate=1 processor.max_cstate=1")
    }

    on-resource fitImage {
        info("Writing FIT image")
        # Write initial fitImage for system A
        fat_write(${BOOT_PART_OFFSET}, "fitImage_A")
        # Cleanup any old system B image
        fat_rm(${BOOT_PART_OFFSET}, "fitImage_B")
    }

    on-resource rootfs.img {
        info("Writing root filesystem to partition A")
        # write to the first rootfs partition
        raw_write(${ROOTFS_A_PART_OFFSET})
    }

    on-finish {
        info("Finalizing eMMC firmware")
        # Clear out any old data in the B partition that might be mistaken for
        # a file system. This is mostly to avoid confusion in humans when
        # reprogramming SDCards with unknown contents.
        raw_memset(${ROOTFS_B_PART_OFFSET}, 256, 0xff)

        # Invalidate the application data partition so that it is guaranteed to
        # trigger the corrupt filesystem detection code on first boot and get
        # formatted. If this isn't done and an old SDCard is reused, the
        # application data could be in a weird state.
        raw_memset(${APP_PART_OFFSET}, 256, 0xff)

        info("eMMC setup done")
    }
}

# This firmware task creates a bootable SD card from a host PC
# Use this for burning SD cards for development/production
task sdcard {
    # Ensure we're writing to an unmounted device
    require-unmounted-destination = true

    on-init {
        info("Creating bootable SD card for Kontron AL/BL i.MX8M Mini")

        # Write partition table
        mbr_write(mbr)

        # Create and setup boot partition
        fat_mkfs(${BOOT_PART_OFFSET}, ${BOOT_PART_COUNT})
        fat_setlabel(${BOOT_PART_OFFSET}, "BOOT")

        uboot_clearenv(uboot-env)
    }

    on-resource uboot {
        info("Writing U-Boot bootloader")
        # Write U-Boot at 33KB offset (required by i.MX8MM boot ROM)
        raw_write(${UBOOT_OFFSET})
    }

    on-resource primary-uboot-env {
        info("Writing U-Boot main environment")
        raw_write(${UBOOT_ENV_PRIMARY_OFFSET})
    }

    on-resource secondary-uboot-env {
        info("Writing U-Boot redundant environment")
        raw_write(${UBOOT_ENV_SECONDARY_OFFSET})

        info("Customising U-Boot environment")

        # Override/customize specific variables for factory initialization
        uboot_setenv(uboot-env, "valid_system", "a")
        uboot_setenv(uboot-env, "active_system", "a")
        uboot_setenv(uboot-env, "update_available", "0")
        uboot_setenv(uboot-env, "update_fallback", "0")

        # Initialize system A metadata
        uboot_setenv(uboot-env, "systema_firmware_uuid", "\${FWUP_META_UUID}")
        uboot_setenv(uboot-env, "systema_firmware_version", ${GRISP_FW_VERSION})
        uboot_setenv(uboot-env, "systema_firmware_vcs_id", ${GRISP_FW_VCS_IDENTIFIER})
        uboot_setenv(uboot-env, "systema_firmware_author", ${GRISP_FW_AUTHOR})

        # Add extra kernel parameters for RT isolation
        # CPU 3 isolated for RT, CPUs 0-2 available for normal system tasks
        uboot_setenv(uboot-env, "bootargs_extra", "isolcpus=3 nohz_full=3 rcu_nocbs=3 rcu_nocb_poll intel_idle.max_cstate=1 processor.max_cstate=1")

        # Additional environment variables for SD card boot
        uboot_setenv(uboot-env, "bootdelay", "3")
    }

    on-resource fitImage {
        info("Writing FIT image")
        # Write fitImage to A slot only
        fat_write(${BOOT_PART_OFFSET}, "fitImage")
    }

    on-resource rootfs.img {
        info("Writing root filesystem to partition A")
        # Write rootfs to partition A (active partition)
        raw_write(${ROOTFS_A_PART_OFFSET})
    }

    on-finish {
        info("Finalizing SD card")

        # Format the application partition as F2FS
        # Note: This creates a filesystem signature that will be detected on first boot
        # The actual formatting will be done by the system on first boot
        raw_memset(${APP_PART_OFFSET}, 256, 0xff)

        info("SD card setup done")
    }
}

# This firmware task updates system A when system B is currently active
task update.a {
    # Verify we are running from system B
    require-partition-offset(1, ${ROOTFS_B_PART_OFFSET})

    # Verify that partition B is currently active
    require-uboot-variable(uboot-env, "active_system", "b")

    # Verify the expected platform/architecture
    require-uboot-variable(uboot-env, "system_platform", "${GRISP_FW_PLATFORM}")
    require-uboot-variable(uboot-env, "system_architecture", "${GRISP_FW_ARCHITECTURE}")

    # Upgrade to partition A
    on-init {
        info("Upgrading system A (currently running from B)")

        # Any already updated system will be destroyed
        uboot_setenv(uboot-env, "update_available", "0")

        # Override system A metadata
        uboot_setenv(uboot-env, "systema_firmware_uuid", "\${FWUP_META_UUID}")
        uboot_setenv(uboot-env, "systema_firmware_version", ${GRISP_FW_VERSION})
        uboot_setenv(uboot-env, "systema_firmware_vcs_id", ${GRISP_FW_VCS_IDENTIFIER})
        uboot_setenv(uboot-env, "systema_firmware_author", ${GRISP_FW_AUTHOR})

        # Indicate that the entire partition can be cleared
        trim(${ROOTFS_A_PART_OFFSET}, ${ROOTFS_A_PART_COUNT})
    }

    # NOTE: U-Boot bootloader is NOT updated during upgrades for safety
    # Only complete installations should update the bootloader

    on-resource fitImage {
        fat_write(${BOOT_PART_OFFSET}, "fitImage_A")
    }

    on-resource rootfs.img {
        raw_write(${ROOTFS_A_PART_OFFSET})
    }

    on-finish {
        uboot_setenv(uboot-env, "update_available", "1")
        info("System A updated")
    }

    on-error {
    }
}

# This firmware task updates system B when system A is currently active
task update.b {
    # Verify we are running from system A
    require-partition-offset(1, ${ROOTFS_A_PART_OFFSET})

    # Verify that partition A is currently active
    require-uboot-variable(uboot-env, "active_system", "a")

    # Verify the expected platform/architecture
    require-uboot-variable(uboot-env, "system_platform", "${GRISP_FW_PLATFORM}")
    require-uboot-variable(uboot-env, "system_architecture", "${GRISP_FW_ARCHITECTURE}")

    # Upgrade to partition B
    on-init {
        info("Upgrading system B (currently running from A)")

        # Any already updated system will be destroyed
        uboot_setenv(uboot-env, "update_available", "0")

        # Override system B metadata
        uboot_setenv(uboot-env, "systemb_firmware_uuid", "\${FWUP_META_UUID}")
        uboot_setenv(uboot-env, "systemb_firmware_version", ${GRISP_FW_VERSION})
        uboot_setenv(uboot-env, "systemb_firmware_vcs_id", ${GRISP_FW_VCS_IDENTIFIER})
        uboot_setenv(uboot-env, "systemb_firmware_author", ${GRISP_FW_AUTHOR})

        # Indicate that the entire partition can be cleared
        trim(${ROOTFS_B_PART_OFFSET}, ${ROOTFS_B_PART_COUNT})
    }

    # NOTE: U-Boot bootloader is NOT updated during upgrades for safety
    # Only complete installations should update the bootloader

    on-resource fitImage {
        fat_write(${BOOT_PART_OFFSET}, "fitImage_B")
    }

    on-resource rootfs.img {
        raw_write(${ROOTFS_B_PART_OFFSET})
    }

    on-finish {
        uboot_setenv(uboot-env, "update_available", "1")
        info("System B updated")
    }

    on-error {
    }
}

# This task handles unexpected active partition states
task update.unexpected {
    require-uboot-variable(uboot-env, "system_platform", "${GRISP_FW_PLATFORM}")
    require-uboot-variable(uboot-env, "system_architecture", "${GRISP_FW_ARCHITECTURE}")
    on-init {
         error("It doesn't look like either the A or B systems are active.")
    }
}

# This task handles platform/architecture mismatches
task update.wrongplatform {
    on-init {
        error("Expecting platform=${GRISP_FW_PLATFORM} and architecture=${GRISP_FW_ARCHITECTURE}")
    }
}
