#!/usr/bin/env escript
%%! -smp enable -noinput

%% Self-contained artefact HTTP/HTTPS server
%% - Serves files from a root directory (default: ./artefacts)
%% - Special case: if URL matches <name>/<path_inside>, and <name>.tar exists in root,
%%   the server responds with the file inside the tar without extracting to disk.
%%
%% Secure mode (-S|--security-pack DIR):
%% - Enables HTTPS with mutual TLS (client certificate required)
%% - Uses server key/cert from: DIR/servers/<name>.key.pem and DIR/servers/<name>.fullchain.pem
%% - Verifies clients against:  DIR/clients/devices.chain.pem (required)
%% - Defaults to port 8443 in secure mode (overridable via -p/--port)
%% - TLS versions allowed: TLS 1.2 and TLS 1.3

-mode(compile).

-include_lib("kernel/include/file.hrl").

main(Args) ->
    {Port, RootOpt, SecpackOpt, ServerNameOpt, Debug} = parse_args(Args),
    {ok, Cwd} = file:get_cwd(),
    Root = normalize_root(RootOpt, Cwd),
    ok = ensure_dir(Root),
    case SecpackOpt of
        undefined ->
            io:format("artefact_server: serving ~s on http://0.0.0.0:~p\n", [Root, Port]),
            start_server(Port, Root, Debug);
        _ ->
            _ = application:ensure_all_started(ssl),
            {KeyFile, CertFile, CACertFile} = resolve_tls_materials(SecpackOpt, ServerNameOpt),
            io:format("artefact_server: serving ~s on https://0.0.0.0:~p (mTLS)\n", [Root, Port]),
            start_server_tls(Port, Root, KeyFile, CertFile, CACertFile, Debug)
    end.

parse_args(Args) ->
    parse_args(Args, #{port => 8080, root => "artefacts", secpack => undefined, server_name => undefined, debug => false}).

parse_args(["-p", PortStr | Rest], Acc) ->
    parse_args(Rest, Acc#{port := to_int(PortStr)});
parse_args(["--port", PortStr | Rest], Acc) ->
    parse_args(Rest, Acc#{port := to_int(PortStr)});
parse_args(["-r", Root | Rest], Acc) ->
    parse_args(Rest, Acc#{root := Root});
parse_args(["--root", Root | Rest], Acc) ->
    parse_args(Rest, Acc#{root := Root});
parse_args(["-S", Secpack | Rest], Acc) ->
    % When secpack is specified and port was default, bump to 8443
    Acc1 = case maps:get(port, Acc) of
        8080 -> Acc#{port := 8443};
        P -> Acc#{port := P}
    end,
    parse_args(Rest, Acc1#{secpack := Secpack});
parse_args(["--security-pack", Secpack | Rest], Acc) ->
    Acc1 = case maps:get(port, Acc) of
        8080 -> Acc#{port := 8443};
        P -> Acc#{port := P}
    end,
    parse_args(Rest, Acc1#{secpack := Secpack});
parse_args(["-n", Name | Rest], Acc) ->
    parse_args(Rest, Acc#{server_name := Name});
parse_args(["--name", Name | Rest], Acc) ->
    parse_args(Rest, Acc#{server_name := Name});
parse_args(["-v" | Rest], Acc) ->
    parse_args(Rest, Acc#{debug := true});
parse_args(["--verbose" | Rest], Acc) ->
    parse_args(Rest, Acc#{debug := true});
parse_args(["-h" | _], Acc) ->
    usage(),
    halt_ok(Acc);
parse_args(["--help" | _], Acc) ->
    usage(),
    halt_ok(Acc);
parse_args([], #{port := Port, root := Root, secpack := Secpack, server_name := Name, debug := Debug}) ->
    {Port, Root, Secpack, Name, Debug};
parse_args([Unknown | _], _Acc) ->
    io:format(standard_error, "Unknown option: ~s\n", [Unknown]),
    usage(),
    halt_error().

usage() ->
    io:format(
      "Usage: artefact_server [OPTIONS]\n"
      "\n"
      "Options:\n"
      "  -p, --port                  HTTP(S) port (default: 8080; 8443 when -S is used)\n"
      "  -r, --root                  Root directory to serve (default: ./artefacts)\n"
      "  -S, --security-pack DIR     Enable HTTPS + client auth using security pack at DIR\n"
      "                               Requires DIR/devices/devices.chain.pem (devices CA bundle)\n"
      "                               Uses DIR/servers/<name>.key.pem and <name>.fullchain.pem\n"
      "  -n, --name NAME             Server identity name; default is the first key in DIR/servers\n"
      "  -v, --verbose               Log each request as: METHOD CODE PATH\n\n").

halt_ok(_Acc) ->
    erlang:halt(0).

halt_error() ->
    erlang:halt(1).

to_int(Str) ->
    try list_to_integer(Str) of
        I when I > 0 -> I
    catch _:_ ->
        io:format(standard_error, "Invalid integer: ~p\n", [Str]),
        halt_error()
    end.

normalize_root(Root, Cwd) when is_list(Root) ->
    case filename:pathtype(Root) of
        absolute -> filename:absname(Root);
        relative -> filename:absname(filename:join(Cwd, Root))
    end.

ensure_dir(Path) ->
    case filelib:is_dir(Path) of
        true -> ok;
        false ->
            io:format(standard_error, "Root does not exist: ~s\n", [Path]),
            halt_error()
    end.

start_server(Port, Root, Debug) ->
    {ok, Listen} = gen_tcp:listen(Port, [binary, {packet, raw}, {reuseaddr, true}, {active, false}]),
    accept_loop(Listen, Root, Debug).

start_server_tls(Port, Root, KeyFile, CertFile, CACertFile, Debug) ->
    {ok, Listen} = ssl:listen(Port, [binary, {reuseaddr, true}, {active, false},
                                     {certfile, CertFile}, {keyfile, KeyFile},
                                     {cacertfile, CACertFile}, {verify, verify_peer},
                                     {fail_if_no_peer_cert, true}, {depth, 3},
                                     {versions, ['tlsv1.2','tlsv1.3']}]),
    accept_loop_tls(Listen, Root, Debug).

accept_loop(Listen, Root, Debug) ->
    case gen_tcp:accept(Listen) of
        {ok, Sock} ->
            spawn(fun() -> handle_client(Sock, Root, Debug) end),
            accept_loop(Listen, Root, Debug);
        {error, closed} -> ok
    end.

accept_loop_tls(Listen, Root, Debug) ->
    case ssl:transport_accept(Listen) of
        {ok, Sock0} ->
            case ssl:handshake(Sock0) of
                {ok, SSLSock} -> spawn(fun() -> handle_client_tls(SSLSock, Root, Debug) end);
                {error, _} -> ok
            end,
            accept_loop_tls(Listen, Root, Debug);
        {error, closed} -> ok
    end.

handle_client(Sock, Root, Debug) ->
    inet:setopts(Sock, [{nodelay, true}]),
    case recv_request(Sock) of
        {ok, #{method := Method, path := Path, httpver := Ver, headers := Headers}} ->
            Response = handle_request(Method, Path, Ver, Headers, Root),
            Status = case Response of {stream, C, _, _} -> C; {C, _, _} -> C end,
            log_request(Debug, Method, Status, Path),
            send_response(Sock, Response);
        {error, _} -> ok
    end,
    gen_tcp:close(Sock).

handle_client_tls(Sock, Root, Debug) ->
    case recv_request_tls(Sock) of
        {ok, #{method := Method, path := Path, httpver := Ver, headers := Headers}} ->
            Response = handle_request(Method, Path, Ver, Headers, Root),
            Status = case Response of {stream, C, _, _} -> C; {C, _, _} -> C end,
            log_request(Debug, Method, Status, Path),
            send_response_tls(Sock, Response);
        {error, _} -> ok
    end,
    ssl:close(Sock).

recv_request(Sock) ->
    case recv_until_blank_line(Sock, <<>>) of
        {ok, Data} -> parse_request(Data);
        Error -> Error
    end.

recv_until_blank_line(Sock, Acc) ->
    case gen_tcp:recv(Sock, 0, 60000) of
        {ok, Bin} ->
            New = <<Acc/binary, Bin/binary>>,
            case binary:match(New, <<"\r\n\r\n">>) of
                {_, _} -> {ok, New};
                nomatch -> recv_until_blank_line(Sock, New)
            end;
        Error -> Error
    end.

recv_request_tls(Sock) ->
    case recv_until_blank_line_tls(Sock, <<>>) of
        {ok, Data} -> parse_request(Data);
        Error -> Error
    end.

recv_until_blank_line_tls(Sock, Acc) ->
    case ssl:recv(Sock, 0, 60000) of
        {ok, Bin} ->
            New = <<Acc/binary, Bin/binary>>,
            case binary:match(New, <<"\r\n\r\n">>) of
                {_, _} -> {ok, New};
                nomatch -> recv_until_blank_line_tls(Sock, New)
            end;
        Error -> Error
    end.

parse_request(Bin) ->
    case split_header_body(Bin) of
        {Header, _Body} ->
            Lines = binary:split(Header, <<"\r\n">>, [global]),
            case Lines of
                [ReqLine | Rest] ->
                    case parse_request_line(ReqLine) of
                        {ok, Method, RawPath, Ver} ->
                            Headers = parse_headers(Rest, #{}),
                            {ok, #{method => Method, path => RawPath, httpver => Ver, headers => Headers}};
                        _ -> {error, bad_request}
                    end;
                _ -> {error, bad_request}
            end
    end.

split_header_body(Bin) ->
    case binary:split(Bin, <<"\r\n\r\n">>) of
        [Header, Body] -> {Header, Body};
        _ -> {Bin, <<>>}
    end.

parse_request_line(Line) ->
    Parts0 = binary:split(Line, <<" ">>, [global]),
    Parts = [P || P <- Parts0, P =/= <<>>],
    case Parts of
        [Method, Path, Ver] -> {ok, Method, Path, Ver};
        _ -> {error, bad_request}
    end.

parse_headers([<<>> | _], Acc) -> Acc;
parse_headers([<<"\r">> | _], Acc) -> Acc;
parse_headers([H | T], Acc) when is_binary(H), H =/= <<>> ->
    case binary:match(H, <<":">>) of
        {Pos, _Len} ->
            K = binary:part(H, 0, Pos),
            V0 = binary:part(H, Pos + 1, byte_size(H) - Pos - 1),
            V = trim_leading_spaces(V0),
            parse_headers(T, maps:put(string:lowercase(binary_to_list(K)), V, Acc));
        nomatch ->
            parse_headers(T, Acc)
    end;
parse_headers([], Acc) -> Acc.

trim_leading_spaces(<<$\s, Rest/binary>>) -> trim_leading_spaces(Rest);
trim_leading_spaces(Bin) -> Bin.

handle_request(<<"GET">>, RawPath, _Ver, _Headers, Root) ->
    handle_get_or_head(get, RawPath, Root);
handle_request(<<"HEAD">>, RawPath, _Ver, _Headers, Root) ->
    handle_get_or_head(head, RawPath, Root);
handle_request(_Other, _RawPath, _Ver, _Headers, _Root) ->
    {405, #{<<"content-type">> => <<"text/plain">>}, <<"Method Not Allowed">> }.

handle_get_or_head(Verb, RawPath, Root) ->
    Path0 = strip_query(RawPath),
    Decoded = urldecode(Path0),
    case sanitize_path(Decoded) of
        {ok, Segments} ->
            route_request(Verb, Segments, Root);
        {error, _} ->
            {400, #{<<"content-type">> => <<"text/plain">>}, <<"Bad Request">>}
    end.

strip_query(Path) ->
    case binary:match(Path, <<"?">>) of
        {Pos, _Len} -> binary:part(Path, 0, Pos);
        nomatch -> Path
    end.

urldecode(Bin) when is_binary(Bin) ->
    list_to_binary(uri_string:unquote(binary_to_list(Bin))).

sanitize_path(<<"/">>) -> {ok, []};
sanitize_path(Path) when is_binary(Path) ->
    Str = binary_to_list(Path),
    case Str of
        "/" ++ Rest -> sanitize_path(list_to_binary(Rest));
        _ ->
            Segs = [S || S <- string:tokens(Str, "/"), S =/= ""],
            case lists:any(fun(S) -> S =:= ".." end, Segs) of
                true -> {error, unsafe};
                false -> {ok, Segs}
            end
    end.

route_request(_Verb, [], Root) ->
    list_index(Root);
route_request(Verb, Segments, Root) ->
    PathRel = filename:join(Segments),
    Full = filename:join(Root, PathRel),
    case filelib:is_file(Full) of
        true ->
            case path_has_symlink(Root, Segments) of
                true -> {404, #{<<"content-type">> => <<"text/plain">>}, <<"Not Found">>};
                false -> serve_file(Verb, Full)
            end;
        false ->
            tar_route(Verb, Segments, Root)
    end.

tar_route(Verb, [Base | InnerSegs], Root) ->
    TarPath = filename:join(Root, Base ++ ".tar"),
    case filelib:is_file(TarPath) of
        true ->
            case is_symlink(TarPath) of
                true -> {404, #{<<"content-type">> => <<"text/plain">>}, <<"Not Found">>};
                false ->
                    case InnerSegs of
                        [] -> serve_file(Verb, TarPath);
                        _ -> serve_tar_inner(Verb, TarPath, Base, filename:join(InnerSegs))
                    end
            end;
        false -> {404, #{<<"content-type">> => <<"text/plain">>}, <<"Not Found">>}
    end;
tar_route(_Verb, _Segments, _Root) ->
    {404, #{<<"content-type">> => <<"text/plain">>}, <<"Not Found">>}.

serve_file(head, FullPath) ->
    case file:read_file_info(FullPath) of
        {ok, #file_info{size = Size}} ->
            Mime = mime_type(FullPath),
            {200, #{<<"content-type">> => Mime, <<"content-length">> => integer_to_binary(Size)}, <<>>};
        _ -> {404, #{<<"content-type">> => <<"text/plain">>}, <<"Not Found">>}
    end;
serve_file(get, FullPath) ->
    case file:read_file_info(FullPath) of
        {ok, #file_info{size = Size}} ->
            Mime = mime_type(FullPath),
            {stream, 200, #{<<"content-type">> => Mime, <<"content-length">> => integer_to_binary(Size)}, FullPath};
        _ -> {404, #{<<"content-type">> => <<"text/plain">>}, <<"Not Found">>}
    end.

serve_tar_inner(head, TarPath, Base, InnerRel) ->
    case read_tar_member(TarPath, Base, InnerRel) of
        {ok, _Name, Bin} ->
            Mime = mime_type(InnerRel),
            {200, #{<<"content-type">> => Mime, <<"content-length">> => integer_to_binary(byte_size(Bin))}, <<>>};
        {error, _} -> {404, #{<<"content-type">> => <<"text/plain">>}, <<"Not Found">>}
    end;
serve_tar_inner(get, TarPath, Base, InnerRel) ->
    case read_tar_member(TarPath, Base, InnerRel) of
        {ok, _Name, Bin} ->
            Mime = mime_type(InnerRel),
            {200, #{<<"content-type">> => Mime, <<"content-length">> => integer_to_binary(byte_size(Bin))}, Bin};
        {error, _} -> {404, #{<<"content-type">> => <<"text/plain">>}, <<"Not Found">>}
    end.

read_tar_member(TarPath, Base, InnerRel) ->
    Candidates = [
        InnerRel,
        filename:join(Base, InnerRel),
        filename:join("./", InnerRel),
        filename:join("./" ++ Base, InnerRel)
    ],
    try_candidates(TarPath, Candidates).

try_candidates(_TarPath, []) -> {error, not_found};
try_candidates(TarPath, [C | Rest]) ->
    case erl_tar:extract(TarPath, [{files, [C]}, memory]) of
        {ok, [{Name, Bin} | _]} ->
            {ok, Name, Bin};
        {ok, []} ->
            try_candidates(TarPath, Rest);
        {error, _} ->
            try_candidates(TarPath, Rest)
    end.

list_index(Root) ->
    case file:list_dir(Root) of
        {ok, Files} ->
            Body = iolist_to_binary([
                <<"artefact_server\n\n">>,
                lists:map(fun(F) -> [F, <<"\n">>] end, lists:sort(Files))
            ]),
            {200, #{<<"content-type">> => <<"text/plain; charset=utf-8">>}, Body};
        _ -> {404, #{<<"content-type">> => <<"text/plain">>}, <<"Not Found">>}
    end.

%% --- Symlink and path safety helpers ---

is_symlink(Path) ->
    case file:read_link_info(Path) of
        {ok, #file_info{type = symlink}} -> true;
        _ -> false
    end.

path_has_symlink(Root, Segments) ->
    path_has_symlink(Root, Segments, Root).

path_has_symlink(_Root, [], _AccPath) -> false;
path_has_symlink(Root, [Seg | Rest], AccPath) ->
    Next = filename:join(AccPath, Seg),
    case file:read_link_info(Next) of
        {ok, #file_info{type = symlink}} -> true;
        {ok, _} -> path_has_symlink(Root, Rest, Next);
        {error, _} -> false
    end.

mime_type(Path) when is_list(Path) -> mime_type(list_to_binary(Path));
mime_type(PathBin) when is_binary(PathBin) ->
    Ext = filename:extension(PathBin),
    case string:lowercase(binary_to_list(Ext)) of
        ".tar" -> <<"application/x-tar">>;
        ".gz" -> <<"application/gzip">>;
        ".xz" -> <<"application/x-xz">>;
        ".bz2" -> <<"application/x-bzip2">>;
        ".txt" -> <<"text/plain; charset=utf-8">>;
        ".md" -> <<"text/markdown; charset=utf-8">>;
        ".json" -> <<"application/json">>;
        ".fw" -> <<"application/octet-stream">>;
        ".bin" -> <<"application/octet-stream">>;
        _ -> <<"application/octet-stream">>
    end.

send_response(Sock, {stream, Code, Headers, FilePath}) ->
    StatusLine = status_line(Code),
    HeaderBin = headers_binary(Headers),
    ok = gen_tcp:send(Sock, [StatusLine, HeaderBin, <<"\r\n">>]),
    stream_file(Sock, FilePath);
send_response(Sock, {Code, Headers, Body}) ->
    StatusLine = status_line(Code),
    HB = ensure_content_length(Headers, Body),
    HeaderBin = headers_binary(HB),
    gen_tcp:send(Sock, [StatusLine, HeaderBin, <<"\r\n">>, Body]).

send_response_tls(Sock, {stream, Code, Headers, FilePath}) ->
    StatusLine = status_line(Code),
    HeaderBin = headers_binary(Headers),
    ok = ssl:send(Sock, [StatusLine, HeaderBin, <<"\r\n">>]),
    stream_file_tls(Sock, FilePath);
send_response_tls(Sock, {Code, Headers, Body}) ->
    StatusLine = status_line(Code),
    HB = ensure_content_length(Headers, Body),
    HeaderBin = headers_binary(HB),
    ssl:send(Sock, [StatusLine, HeaderBin, <<"\r\n">>, Body]).

status_line(Code) ->
    <<"HTTP/1.1 ", (integer_to_binary(Code))/binary, " ", (status_text(Code))/binary, "\r\n">>.

status_text(200) -> <<"OK">>;
status_text(400) -> <<"Bad Request">>;
status_text(404) -> <<"Not Found">>;
status_text(405) -> <<"Method Not Allowed">>;
status_text(_) -> <<"OK">>.

headers_binary(Map) ->
    iolist_to_binary(
      [ [K, <<": ">>, V, <<"\r\n">>] || {K, V} <- maps:to_list(Map) ]
    ).

log_request(true, Method, Status, Path) ->
    io:format("~s ~p ~s\n", [binary_to_list(Method), Status, binary_to_list(Path)]);
log_request(false, _Method, _Status, _Path) ->
    ok.

ensure_content_length(Headers, Body) ->
    case maps:is_key(<<"content-length">>, Headers) of
        true -> Headers;
        false -> maps:put(<<"content-length">>, integer_to_binary(byte_size(Body)), Headers)
    end.

stream_file(Sock, FilePath) ->
    case file:open(FilePath, [read, raw, binary]) of
        {ok, Fd} ->
            stream_file_loop(Sock, Fd),
            file:close(Fd);
        _ -> ok
    end.

stream_file_loop(Sock, Fd) ->
    case file:read(Fd, 65536) of
        {ok, Bin} ->
            ok = gen_tcp:send(Sock, Bin),
            stream_file_loop(Sock, Fd);
        eof -> ok;
        {error, _} -> ok
    end.

stream_file_tls(Sock, FilePath) ->
    case file:open(FilePath, [read, raw, binary]) of
        {ok, Fd} ->
            stream_file_loop_tls(Sock, Fd),
            file:close(Fd);
        _ -> ok
    end.

stream_file_loop_tls(Sock, Fd) ->
    case file:read(Fd, 65536) of
        {ok, Bin} ->
            ok = ssl:send(Sock, Bin),
            stream_file_loop_tls(Sock, Fd);
        eof -> ok;
        {error, _} -> ok
    end.

%% --- TLS material resolution from secpack ---

resolve_tls_materials(SecpackDir, ServerNameOpt) ->
    Root = normalize_root(SecpackDir, filename:absname(".")),
    ensure_dir(Root),
    ServersDir = filename:join(Root, "servers"),
    ensure_dir(ServersDir),
    DevicesDir = filename:join(Root, "devices"),
    ensure_dir(DevicesDir),
    ServerName = case ServerNameOpt of
        undefined -> pick_first_server_basename(ServersDir);
        N -> N
    end,
    Key = filename:join(ServersDir, ServerName ++ ".key.pem"),
    Cert = filename:join(ServersDir, ServerName ++ ".fullchain.pem"),
    ok = ensure_file(Key),
    ok = ensure_file(Cert),
    CACert = filename:join(DevicesDir, "devices.chain.pem"),
    ok = ensure_file(CACert),
    {Key, Cert, CACert}.

pick_first_server_basename(ServersDir) ->
    {ok, Files} = file:list_dir(ServersDir),
    Keys = [ F || F <- lists:sort(Files), lists:suffix(".key.pem", F) ],
    case Keys of
        [H | _] -> filename:basename(H, ".key.pem");
        [] ->
            io:format(standard_error, "No server key found in ~s\n", [ServersDir]),
            halt_error()
    end.

ensure_file(Path) ->
    case filelib:is_file(Path) of
        true -> ok;
        false ->
            io:format(standard_error, "File not found: ~s\n", [Path]),
            halt_error()
    end.
